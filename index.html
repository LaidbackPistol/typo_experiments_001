<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Typography Experiment</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: monospace;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      height: 100vh;
      width: 100vw;
      cursor: crosshair;
    }

    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #typography-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 8px;
      backdrop-filter: blur(5px);
      z-index: 100;
      opacity: 0.3;
      transition: opacity 0.3s ease;
    }

    .controls:hover {
      opacity: 1;
    }

    .control-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .control-label {
      font-size: 12px;
      width: 120px;
    }

    input[type="range"] {
      width: 120px;
      background: transparent;
    }

    input[type="color"] {
      width: 30px;
      height: 30px;
      border: none;
      background: none;
      cursor: pointer;
    }

    select, button {
      background: rgba(30, 30, 30, 0.8);
      color: #fff;
      border: 1px solid #555;
      padding: 5px;
      border-radius: 4px;
      cursor: pointer;
    }

    button {
      width: 100%;
      margin-top: 5px;
      transition: background 0.3s ease;
    }

    button:hover {
      background: rgba(60, 60, 60, 0.8);
    }

    .text-input {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
      padding: 10px;
      border-radius: 8px;
      z-index: 100;
      opacity: 0.3;
      transition: opacity 0.3s ease;
    }

    .text-input:hover {
      opacity: 1;
    }

    #text-content {
      background: rgba(30, 30, 30, 0.8);
      color: #fff;
      border: 1px solid #555;
      padding: 5px;
      border-radius: 4px;
      width: 200px;
    }

    /* Preset System Styles */
    .preset-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(5px);
      padding: 15px;
      border-radius: 8px;
      z-index: 100;
      width: 300px;
      max-height: 80vh;
      overflow-y: auto;
      transform: translateX(320px);
      transition: transform 0.3s ease;
    }

    .preset-panel.open {
      transform: translateX(0);
    }

    .preset-panel h3 {
      margin-bottom: 10px;
      font-size: 16px;
    }

    .preset-list {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin-bottom: 15px;
      max-height: 200px;
      overflow-y: auto;
    }

    .preset-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px;
      border: 1px solid #333;
      border-radius: 4px;
    }

    .preset-item:hover {
      background: rgba(60, 60, 60, 0.5);
    }

    .preset-actions {
      display: flex;
      gap: 5px;
    }

    .preset-actions button {
      width: auto;
      padding: 2px 5px;
      margin: 0;
      font-size: 11px;
    }

    #preset-name {
      width: 100%;
      margin-bottom: 10px;
      background: rgba(30, 30, 30, 0.8);
      color: #fff;
      border: 1px solid #555;
      padding: 5px;
      border-radius: 4px;
    }

    #preset-code {
      width: 100%;
      height: 100px;
      margin-top: 10px;
      background: rgba(30, 30, 30, 0.8);
      color: #fff;
      border: 1px solid #555;
      padding: 5px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 11px;
      resize: vertical;
    }

    .preset-buttons {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .preset-buttons button {
      flex: 1;
    }

    .toggle-preset-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 101;
      border: 1px solid #444;
      font-weight: bold;
      font-size: 18px;
    }

    .toggle-preset-panel:hover {
      background: rgba(50, 50, 50, 0.7);
    }

    .notification {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 4px;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .notification.show {
      opacity: 1;
    }

    /* Built-in presets section */
    .preset-category {
      margin-bottom: 15px;
    }

    .preset-category h4 {
      margin-bottom: 5px;
      font-size: 14px;
      color: #aaa;
      border-bottom: 1px solid #333;
      padding-bottom: 3px;
    }
  </style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="typography-canvas"></canvas>
  </div>
  <div class="text-input">
    <input type="text" id="text-content" placeholder="Type something..." value="EN5EMBLE">
  </div>
  <div class="controls">
    <div class="control-group">
      <span class="control-label">Font Size</span>
      <input type="range" id="font-size" min="50" max="400" value="138">
    </div>
    <div class="control-group">
      <span class="control-label">Duplications</span>
      <input type="range" id="duplications" min="1" max="20" value="20">
    </div>
    <div class="control-group">
      <span class="control-label">Blur Intensity</span>
      <input type="range" id="blur" min="0" max="50" value="50">
    </div>
    <div class="control-group">
      <span class="control-label">Rotation Speed</span>
      <input type="range" id="rotation-speed" min="0" max="10" value="0">
    </div>
    <div class="control-group">
      <span class="control-label">Distortion</span>
      <input type="range" id="distortion" min="0" max="1000" value="1000">
    </div>
    <div class="control-group">
      <span class="control-label">Primary Color</span>
      <input type="color" id="primary-color" value="#ffffff">
    </div>
    <div class="control-group">
      <span class="control-label">Secondary Color</span>
      <input type="color" id="secondary-color" value="#ffffff">
    </div>
    <div class="control-group">
      <span class="control-label">Effect Type</span>
      <select id="effect-type">
        <option value="glitch">Glitch</option>
        <option value="wave">Wave</option>
        <option value="fracture">Fracture</option>
        <option value="spiral">Spiral</option>
      </select>
    </div>
    <div class="control-group">
      <span class="control-label">Font Type</span>
      <select id="font-type">
        <option value="sans-serif">Sans-serif</option>
        <option value="serif">Serif</option>
        <option value="monospace">Monospace</option>
        <option value="cursive">Cursive</option>
      </select>
    </div>
    <!-- Transition time control -->
    <div class="control-group">
      <span class="control-label">Transition Time</span>
      <input type="range" id="transition-time" min="0.01" max="0.5" step="0.01" value="0.1">
    </div>
    <button id="randomize">Randomize</button>
    <button id="save-preset-btn">Save Preset</button>
  </div>

  <!-- Preset Toggle Button -->
  <div class="toggle-preset-panel">P</div>

  <!-- Preset Panel -->
  <div class="preset-panel">
    <h3>Typography Presets</h3>
    
    <!-- Built-in Presets -->
    <div class="preset-category">
      <h4>Built-in Presets</h4>
      <div class="preset-list" id="builtin-preset-list">
        <!-- Built-in presets will be loaded here -->
      </div>
    </div>
    
    <!-- User Presets -->
    <div class="preset-category">
      <h4>Your Presets</h4>
      <div class="preset-list" id="user-preset-list">
        <!-- User presets will be loaded here -->
      </div>
    </div>
    
    <!-- Save New Preset Form -->
    <h4>Create New Preset</h4>
    <input type="text" id="preset-name" placeholder="Preset Name">
    <div class="preset-buttons">
      <button id="save-current">Save Current</button>
      <button id="generate-code">Generate Code</button>
    </div>
    
    <!-- Import/Export -->
    <h4>Import/Export</h4>
    <textarea id="preset-code" placeholder="Paste preset code here to import"></textarea>
    <div class="preset-buttons">
      <button id="import-preset">Import</button>
      <button id="export-preset">Export Current</button>
    </div>
  </div>

  <!-- Notification -->
  <div class="notification" id="notification"></div>

  <script>
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    // Canvas center coordinates (globally accessible)
    let centerX = 0;
    let centerY = 0;

    // Mouse/touch/gyro position
    let mouseX = 0;
    let mouseY = 0;

    // Position variables for typography effects
    let xPos = 0;
    let yPos = 0;

    // Variables for UI elements and gyroscope
    let deviceInfoDiv;
    let gyroSupported = false;
    let gyroPermissionGranted = false;
    let deviceRotation = { beta: 0, gamma: 0 };

    document.addEventListener('DOMContentLoaded', () => {
      // Elements
      const canvas = document.getElementById('typography-canvas');
      const ctx = canvas.getContext('2d');
      const textInput = document.getElementById('text-content');

      // Controls
      const fontSizeControl = document.getElementById('font-size');
      const duplicationsControl = document.getElementById('duplications');
      const blurControl = document.getElementById('blur');
      const rotationSpeedControl = document.getElementById('rotation-speed');
      const distortionControl = document.getElementById('distortion');
      const primaryColorControl = document.getElementById('primary-color');
      const secondaryColorControl = document.getElementById('secondary-color');
      const effectTypeControl = document.getElementById('effect-type');
      const fontTypeControl = document.getElementById('font-type');
      const transitionTimeControl = document.getElementById('transition-time');
      const randomizeBtn = document.getElementById('randomize');
      
      // Preset Controls
      const togglePresetPanel = document.querySelector('.toggle-preset-panel');
      const presetPanel = document.querySelector('.preset-panel');
      const userPresetList = document.getElementById('user-preset-list');
      const builtinPresetList = document.getElementById('builtin-preset-list');
      const presetNameInput = document.getElementById('preset-name');
      const saveCurrentBtn = document.getElementById('save-current');
      const generateCodeBtn = document.getElementById('generate-code');
      const importPresetBtn = document.getElementById('import-preset');
      const exportPresetBtn = document.getElementById('export-preset');
      const presetCodeTextarea = document.getElementById('preset-code');
      const savePresetBtn = document.getElementById('save-preset-btn');
      const notification = document.getElementById('notification');

      // State
      let text = textInput.value;
      let fontSize = parseInt(fontSizeControl.value);
      let duplications = parseInt(duplicationsControl.value);
      let blur = parseInt(blurControl.value);
      let rotationSpeed = parseFloat(rotationSpeedControl.value);
      let distortion = parseInt(distortionControl.value);
      let primaryColor = primaryColorControl.value;
      let secondaryColor = secondaryColorControl.value;
      let effectType = effectTypeControl.value;
      let fontType = fontTypeControl.value;
      let transitionTime = parseFloat(transitionTimeControl.value);
      
      // Target values for interpolation
      let targetFontSize = fontSize;
      let targetDuplications = duplications;
      let targetBlur = blur;
      let targetRotationSpeed = rotationSpeed;
      let targetDistortion = distortion;
      let targetPrimaryColor = primaryColor;
      let targetSecondaryColor = secondaryColor;
      let targetEffectType = effectType;
      let targetFontType = fontType;
      
      // Interpolation state
      let isInterpolating = false;
      let interpolationStartTime = 0;
      let interpolationDuration = transitionTime * 1000; // in milliseconds
      
      // Previous values for interpolation
      let prevFontSize = fontSize;
      let prevDuplications = duplications;
      let prevBlur = blur;
      let prevRotationSpeed = rotationSpeed;
      let prevDistortion = distortion;
      let prevPrimaryColor = primaryColor;
      let prevSecondaryColor = secondaryColor;
      let prevEffectType = effectType;
      let prevFontType = fontType;
      
      // Animation variables
      let time = 0;
      let isAnimating = true;
      
      // User presets storage
      let userPresets = JSON.parse(localStorage.getItem('typographyPresets')) || [];

      // Add responsive scaling to make typography look consistent across screen sizes
      function getResponsiveScale() {
        // Base dimensions reference (desktop size)
        const baseWidth = 1920;
        const baseHeight = 1080;
        
        // Calculate scaling factors
        const widthScale = canvas.width / baseWidth;
        const heightScale = canvas.height / baseHeight;
        
        // Use the smaller scale to ensure everything fits
        return Math.min(widthScale, heightScale);
      }

      function setCanvasDimensions() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Update global center coordinates whenever canvas dimensions change
        centerX = canvas.width / 2;
        centerY = canvas.height / 2;
              
        // If this is a mobile device, adjust the preset scaling
        if (isMobile) {
          // Use a safety check when accessing potentially undefined variables
          if (typeof deviceInfoDiv !== 'undefined' && deviceInfoDiv) {
            // Now we can safely use deviceInfoDiv
            if (window.orientation === 0 || window.orientation === 180) {
              deviceInfoDiv.textContent += ' (Portrait)';
            } else {
              deviceInfoDiv.textContent += ' (Landscape)';
            }
          }
        }
      }
      
      setCanvasDimensions();
      window.addEventListener('resize', setCanvasDimensions);
      
      // Mouse move event
      window.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      // Device detection
      let gyroSupported = false;
      let gyroPermissionGranted = false;
      let deviceRotation = { beta: 0, gamma: 0 }; // beta: front-to-back tilt, gamma: left-to-right tilt

      // Elements for device info and permissions
      const deviceInfoDiv = document.createElement('div');
      deviceInfoDiv.className = 'device-info';
      deviceInfoDiv.style.cssText = `
        position: fixed;
        top: 80px;
        left: 20px;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(5px);
        padding: 10px;
        border-radius: 8px;
        z-index: 100;
        color: white;
        font-size: 12px;
        opacity: 0.6;
        transition: opacity 0.3s ease;
      `;
      deviceInfoDiv.textContent = isMobile ? 'Mobile device detected' : 'Desktop device detected';
      document.body.appendChild(deviceInfoDiv);

      if (isMobile) {
        // Request gyroscope permission
        const requestGyroButton = document.createElement('button');
        requestGyroButton.textContent = 'Enable Gyroscope';
        requestGyroButton.style.cssText = `
          position: fixed;
          top: 130px;
          left: 20px;
          background: rgba(0, 0, 0, 0.7);
          color: white;
          padding: 8px 15px;
          border-radius: 8px;
          border: 1px solid #444;
          z-index: 100;
          display: none; // Initially hidden
        `;
        
        document.body.appendChild(requestGyroButton);
        
        // Check if DeviceOrientation is available
        if (typeof DeviceOrientationEvent !== 'undefined') {
          gyroSupported = true;
          
          // For iOS 13+ which requires permission
          if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            requestGyroButton.style.display = 'block';
            
            requestGyroButton.addEventListener('click', async () => {
              try {
                const permission = await DeviceOrientationEvent.requestPermission();
                if (permission === 'granted') {
                  gyroPermissionGranted = true;
                  requestGyroButton.style.display = 'none';
                  setupGyroscope();
                  showNotification('Gyroscope enabled');
                } else {
                  showNotification('Gyroscope permission denied');
                }
              } catch (error) {
                console.error('Error requesting gyroscope permission:', error);
                showNotification('Error accessing gyroscope');
              }
            });
          } else {
            // For Android and older iOS which don't require permission
            gyroPermissionGranted = true;
            setupGyroscope();
          }
        } else {
          // Fallback for devices without gyroscope
          deviceInfoDiv.textContent = 'Gyroscope not supported - using touch instead';
          // We'll implement touch fallback later
        }
      }

      // Setup gyroscope event listeners
      function setupGyroscope() {
        window.addEventListener('deviceorientation', (event) => {
          // Normalize gyroscope data to be similar to mouse coordinates
          // beta: front-to-back tilt (-180 to 180), gamma: left-to-right tilt (-90 to 90)
          deviceRotation.beta = event.beta || 0;
          deviceRotation.gamma = event.gamma || 0;
          
          // Map gyroscope data to mouse coordinates
          // We'll use a multiplier to adjust sensitivity
          const sensitivity = 10;
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          
          // Map gamma (-90 to 90) to mouseX, beta (-180 to 180) to mouseY
          // Restricted to a range to prevent extreme values
          mouseX = centerX + (deviceRotation.gamma / 45) * centerX * sensitivity;
          mouseY = centerY + (deviceRotation.beta / 90) * centerY * sensitivity;
          
          // Update device info display
          deviceInfoDiv.textContent = `Gyro: ${deviceRotation.gamma.toFixed(1)}°, ${deviceRotation.beta.toFixed(1)}°`;
        });
      }

      // Add touch support as a fallback
      if (isMobile) {
        canvas.addEventListener('touchmove', (e) => {
          e.preventDefault(); // Prevent scrolling
          if (e.touches.length > 0) {
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
            
            // Update device info if not using gyro
            if (!gyroPermissionGranted) {
              deviceInfoDiv.textContent = `Touch: ${mouseX.toFixed(0)}, ${mouseY.toFixed(0)}`;
            }
          }
        });
      }

      // Update the animation function to use responsive scaling
      // In the existing animate function, add this near the beginning before any drawing:

      // Calculate responsive scale factor
      const responsiveScale = getResponsiveScale();

      // And then modify these lines inside the animate function:
      // Change
      // ctx.font = `${fontSize}px ${fontType}`;
      // To:
      const adjustedFontSize = fontSize * responsiveScale;
      ctx.font = `${adjustedFontSize}px ${fontType}`;

      // Also update the distortion calculation to be responsive:
      // Change the mouseInfluence calculations to:
      const adjustedDistortion = distortion * responsiveScale;
      const mouseInfluenceX = (mouseX - centerX) / centerX * adjustedDistortion;
      const mouseInfluenceY = (mouseY - centerY) / centerY * adjustedDistortion;

      // And in the effects cases, replace distortion with adjustedDistortion:
      // For example in the 'wave' case:
      xPos += Math.sin(time * 2 + progress * Math.PI * 4) * adjustedDistortion;
      yPos += Math.cos(time * 2 + progress * Math.PI * 4) * adjustedDistortion;
      // And the same for other effects

      // Make controls more mobile-friendly
      if (isMobile) {
        // Adjust the controls panel for better touch interaction
        const controls = document.querySelector('.controls');
        controls.style.width = '80%';
        controls.style.maxWidth = '300px';
        controls.style.left = '50%';
        controls.style.transform = 'translateX(-50%)';
        controls.style.padding = '15px';
        
        // Make sliders easier to touch
        const sliders = document.querySelectorAll('input[type="range"]');
        sliders.forEach(slider => {
          slider.style.height = '25px';
        });
        
        // Larger buttons for touch
        const buttons = document.querySelectorAll('button');
        buttons.forEach(button => {
          button.style.padding = '10px';
          button.style.margin = '5px 0';
          button.style.fontSize = '16px';
        });
      }

      // Handle orientation changes
      window.addEventListener('orientationchange', () => {
        // Short delay to allow the browser to complete the orientation change
        setTimeout(() => {
          setCanvasDimensions();
          showNotification('Orientation changed');
        }, 300);
      });

      // Update the setCanvasDimensions function to be more responsive
      function setCanvasDimensions() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // If this is a mobile device, adjust the preset scaling
        if (isMobile) {
          // Force redraw with the new dimensions
          draw();
          
          // Update device info
          if (window.orientation === 0 || window.orientation === 180) {
            deviceInfoDiv.textContent += ' (Portrait)';
          } else {
            deviceInfoDiv.textContent += ' (Landscape)';
          }
        }
      }

      // Add a dedicated mobile UI toggle
      if (isMobile) {
        const mobileUIToggle = document.createElement('button');
        mobileUIToggle.textContent = '≡';
        mobileUIToggle.style.cssText = `
          position: fixed;
          bottom: 20px;
          left: 20px;
          width: 50px;
          height: 50px;
          border-radius: 50%;
          background: rgba(0, 0, 0, 0.7);
          color: white;
          border: 1px solid #444;
          font-size: 24px;
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000;
        `;
        
        document.body.appendChild(mobileUIToggle);
        
        // By default, hide controls on mobile for better viewing experience
        const controls = document.querySelector('.controls');
        controls.style.display = 'none';
        
        mobileUIToggle.addEventListener('click', () => {
          if (controls.style.display === 'none') {
            controls.style.display = 'flex';
            mobileUIToggle.textContent = '×';
          } else {
            controls.style.display = 'none';
            mobileUIToggle.textContent = '≡';
          }
        });
        
        // Make the text input more mobile-friendly
        const textInput = document.getElementById('text-content');
        textInput.style.width = '60%';
        textInput.style.padding = '10px';
        textInput.style.fontSize = '16px'; // Prevent zoom on iOS when focusing
      }

      // Update the draw function to handle different screen orientations
      function draw() {
        // This function can be called directly to force a redraw
        // Calculate responsive scale based on current orientation
        const responsiveScale = getResponsiveScale();
        
        // For mobile devices, we need to adjust the typography positioning
        if (isMobile) {
          // Determine if we're in portrait or landscape
          const isPortrait = window.innerHeight > window.innerWidth;
          
          // Adjust scale factor based on orientation
          // In portrait mode, we may want to reduce size further to fit
          const orientationFactor = isPortrait ? 0.7 : 1;
          
          // Apply adjusted scale to fontSize when drawing
          // This will be used in the animate function
          const adjustedFontSize = fontSize * responsiveScale * orientationFactor;
          
          // We can use this to make any orientation-specific adjustments
        }
      }

      // Improve the getResponsiveScale function to be smarter about different devices
      function getResponsiveScale() {
        // Base dimensions reference (desktop size)
        const baseWidth = 1920;
        const baseHeight = 1080;
        
        // Calculate scaling factors
        const widthScale = canvas.width / baseWidth;
        const heightScale = canvas.height / baseHeight;
        
        // Use the smaller scale to ensure everything fits
        let scale = Math.min(widthScale, heightScale);
        
        // For very small devices, we may want to add a minimum scale
        const minScale = 0.3;
        scale = Math.max(scale, minScale);
        
        // For mobile devices, we can add additional adjustments
        if (isMobile) {
          // Detect if it's a phone or tablet based on screen size
          const isPhone = Math.min(screen.width, screen.height) < 768;
          
          if (isPhone) {
            // Phones may need more aggressive scaling
            scale *= 0.8;
          }
        }
        
        return scale;
      }

      // Add a fullscreen toggle for better mobile experience
      const fullscreenToggle = document.createElement('button');
      fullscreenToggle.textContent = '⛶';
      fullscreenToggle.style.cssText = `
        position: fixed;
        bottom: ${isMobile ? '85px' : '20px'};
        left: 20px;
        width: ${isMobile ? '50px' : '35px'};
        height: ${isMobile ? '50px' : '35px'};
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: 1px solid #444;
        font-size: ${isMobile ? '24px' : '18px'};
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      `;

      document.body.appendChild(fullscreenToggle);

      fullscreenToggle.addEventListener('click', () => {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().catch(err => {
            showNotification(`Error: ${err.message}`);
          });
          fullscreenToggle.textContent = '⤢';
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
            fullscreenToggle.textContent = '⛶';
          }
        }
      });

      // Listen for fullscreen changes
      document.addEventListener('fullscreenchange', () => {
        if (document.fullscreenElement) {
          fullscreenToggle.textContent = '⤢';
          showNotification('Fullscreen mode');
        } else {
          fullscreenToggle.textContent = '⛶';
          showNotification('Exited fullscreen');
        }
        
        // Resize canvas when entering/exiting fullscreen
        setCanvasDimensions();
      });

      // Add a simple loading indicator for mobile devices
      if (isMobile) {
        const loadingIndicator = document.createElement('div');
        loadingIndicator.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: black;
          color: white;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          z-index: 9999;
          font-family: monospace;
          transition: opacity 0.5s ease;
        `;
        
        loadingIndicator.innerHTML = `
          <h2>Typography Experiment</h2>
          <p style="margin: 20px 0;">Loading mobile experience...</p>
          <div style="width: 200px; height: 4px; background: #333; border-radius: 2px; overflow: hidden;">
            <div id="progress-bar" style="width: 0%; height: 100%; background: white; transition: width 0.3s ease;"></div>
          </div>
        `;
        
        document.body.appendChild(loadingIndicator);
        
        // Simulate loading progress
        let progress = 0;
        const progressBar = document.getElementById('progress-bar');
        
        const loadingInterval = setInterval(() => {
          progress += 5;
          progressBar.style.width = `${progress}%`;
          
          if (progress >= 100) {
            clearInterval(loadingInterval);
            setTimeout(() => {
              loadingIndicator.style.opacity = 0;
              setTimeout(() => {
                loadingIndicator.remove();
              }, 500);
            }, 500);
          }
        }, 100);
      }
      
      // Built-in presets
      const builtinPresets = [
        {
          name: "Unsure",
          settings: {
            fontSize: 138,
            duplications: 20,
            blur: 50,
            rotationSpeed: 0,
            distortion: 1000,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "glitch",
            fontType: "sans-serif"
          }
        },
        {
          name: "Beacon of truth",
          settings: {
            fontSize: 50,
            duplications: 20,
            blur: 0,
            rotationSpeed: 3,
            distortion: 390,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "wave",
            fontType: "monospace"
          }
        },
        {
            name: "Skeud",
            settings: {
            fontSize: 168,
            duplications: 9,
            blur: 2,
            rotationSpeed: 5,
            distortion: 0,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "spiral",
            fontType: "serif"
        }
        },
        {
            name: "Arabesque",
            settings: {
            fontSize: 400,
            duplications: 9,
            blur: 2,
            rotationSpeed: 9,
            distortion: 0,
            primaryColor: "#ffffff",
            secondaryColor: "#000000",
            effectType: "spiral",
            fontType: "serif"
        }
        },
        {
            name: "Simple",
            settings: {
            fontSize: 292,
            duplications: 20,
            blur: 50,
            rotationSpeed: 0,
            distortion: 1000,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "wave",
            fontType: "sans-serif"
        }
        }
      ];
      
      // Function to convert hex color to RGB array
      function hexToRgb(hex) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return [r, g, b];
      }
      
      // Function to convert RGB array to hex color
      function rgbToHex(r, g, b) {
        return `#${Math.floor(r).toString(16).padStart(2, '0')}${Math.floor(g).toString(16).padStart(2, '0')}${Math.floor(b).toString(16).padStart(2, '0')}`;
      }
      
      // Function to interpolate between two colors
      function interpolateColor(color1, color2, factor) {
        const rgb1 = hexToRgb(color1);
        const rgb2 = hexToRgb(color2);
        
        const r = rgb1[0] + factor * (rgb2[0] - rgb1[0]);
        const g = rgb1[1] + factor * (rgb2[1] - rgb1[1]);
        const b = rgb1[2] + factor * (rgb2[2] - rgb1[2]);
        
        return rgbToHex(r, g, b);
      }
      
      // Function to show notification
      function showNotification(message) {
        notification.textContent = message;
        notification.classList.add('show');
        setTimeout(() => {
          notification.classList.remove('show');
        }, 2000);
      }
      
      // Function to get current settings
      function getCurrentSettings() {
        return {
          fontSize: parseInt(fontSizeControl.value),
          duplications: parseInt(duplicationsControl.value),
          blur: parseInt(blurControl.value),
          rotationSpeed: parseFloat(rotationSpeedControl.value),
          distortion: parseInt(distortionControl.value),
          primaryColor: primaryColorControl.value,
          secondaryColor: secondaryColorControl.value,
          effectType: effectTypeControl.value,
          fontType: fontTypeControl.value
        };
      }
      
      // Function to apply settings from a preset
      function applySettings(settings) {
        // Save previous values for interpolation
        prevFontSize = fontSize;
        prevDuplications = duplications;
        prevBlur = blur;
        prevRotationSpeed = rotationSpeed;
        prevDistortion = distortion;
        prevPrimaryColor = primaryColor;
        prevSecondaryColor = secondaryColor;
        prevEffectType = effectType;
        prevFontType = fontType;
        
        // Set the UI controls to new values
        fontSizeControl.value = settings.fontSize;
        duplicationsControl.value = settings.duplications;
        blurControl.value = settings.blur;
        rotationSpeedControl.value = settings.rotationSpeed;
        distortionControl.value = settings.distortion;
        primaryColorControl.value = settings.primaryColor;
        secondaryColorControl.value = settings.secondaryColor;
        effectTypeControl.value = settings.effectType;
        fontTypeControl.value = settings.fontType;
        
        // Set target values for interpolation
        targetFontSize = settings.fontSize;
        targetDuplications = settings.duplications;
        targetBlur = settings.blur;
        targetRotationSpeed = settings.rotationSpeed;
        targetDistortion = settings.distortion;
        targetPrimaryColor = settings.primaryColor;
        targetSecondaryColor = settings.secondaryColor;
        targetEffectType = settings.effectType;
        targetFontType = settings.fontType;
        
        // Start interpolation
        isInterpolating = true;
        interpolationStartTime = Date.now();
      }
      
      // Animation function
      function animate() {
        if (!isAnimating) return;

        // Calculate responsive scale factor
        const responsiveScale = getResponsiveScale();

        // Handle interpolation
        if (isInterpolating) {
          const currentTime = Date.now();
          const elapsed = currentTime - interpolationStartTime;
          let progress = Math.min(elapsed / interpolationDuration, 1);
          
          // Ease in-out function for smoother transitions
          progress = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;
          
          // Interpolate numeric values
          fontSize = Math.round(prevFontSize + (targetFontSize - prevFontSize) * progress);
          duplications = Math.round(prevDuplications + (targetDuplications - prevDuplications) * progress);
          blur = Math.round(prevBlur + (targetBlur - prevBlur) * progress);
          rotationSpeed = prevRotationSpeed + (targetRotationSpeed - prevRotationSpeed) * progress;
          distortion = Math.round(prevDistortion + (targetDistortion - prevDistortion) * progress);
          
          // Interpolate colors
          primaryColor = interpolateColor(prevPrimaryColor, targetPrimaryColor, progress);
          secondaryColor = interpolateColor(prevSecondaryColor, targetSecondaryColor, progress);
          
          // For effect type and font type, we switch immediately at the midpoint of interpolation
          if (progress >= 0.5) {
            effectType = targetEffectType;
            fontType = targetFontType;
          }
          
          // Update UI controls to reflect current interpolated values
          fontSizeControl.value = fontSize;
          duplicationsControl.value = duplications;
          blurControl.value = blur;
          rotationSpeedControl.value = rotationSpeed;
          distortionControl.value = distortion;
          primaryColorControl.value = primaryColor;
          secondaryColorControl.value = secondaryColor;
          
          // End interpolation when complete
          if (progress >= 1) {
            isInterpolating = false;
            effectType = targetEffectType;
            fontType = targetFontType;
          }
        }
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Update time
        time += 0.01 * rotationSpeed;
        
        // Apply canvas-level blur if needed
        if (blur > 0) {
          ctx.filter = `blur(${blur / 5}px)`;
        } else {
          ctx.filter = 'none';
        }
        
        // Calculate center position
        // const centerX = canvas.width / 2;
        // const centerY = canvas.height / 2;
        
        // Calculate mouse influence
       // Modify mouse influence calculations
        const adjustedDistortion = distortion * responsiveScale;
        const mouseInfluenceX = (mouseX - centerX) / centerX * adjustedDistortion;
        const mouseInfluenceY = (mouseY - centerY) / centerY * adjustedDistortion;
        
        // Set text properties
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Draw each duplication
        for (let i = 0; i < duplications; i++) {
          const progress = i / duplications;
          const angle = time + progress * Math.PI * 2;

          // IMPORTANT: Initialize xPos and yPos here first before using them
          xPos = centerX + mouseInfluenceX * Math.sin(progress * Math.PI * 2);
          yPos = centerY + mouseInfluenceY * Math.cos(progress * Math.PI * 2);
          
          // Color gradient based on progress
          const ratio = progress;
          const color = interpolateColor(primaryColor, secondaryColor, ratio);
          ctx.fillStyle = color;
          
          // Apply effect-specific transformations
          ctx.save();
          
          // Base position influenced by mouse
          let xPos = centerX + mouseInfluenceX * Math.sin(progress * Math.PI * 2);
          let yPos = centerY + mouseInfluenceY * Math.cos(progress * Math.PI * 2);
          
          let scaleFactor = 1;
          let rotationAngle = angle * rotationSpeed;
          
          switch (effectType) {
            case 'wave':
              xPos += Math.sin(time * 2 + progress * Math.PI * 4) * adjustedDistortion;
              yPos += Math.cos(time * 2 + progress * Math.PI * 4) * adjustedDistortion;
              break;
              
            case 'fracture':
              xPos += (Math.random() - 0.5) * adjustedDistortion * 2;
              yPos += (Math.random() - 0.5) * adjustedDistortion * 2;
              rotationAngle += (Math.random() - 0.5) * adjustedDistortion / 100;
              break;
              
            case 'spiral':
              const spiralRadius = progress * adjustedDistortion * 2;
              xPos += Math.cos(angle * 3) * spiralRadius;
              yPos += Math.sin(angle * 3) * spiralRadius;
              break;
              
            case 'glitch':
              if (Math.random() > 0.7) {
                xPos += (Math.random() - 0.5) * adjustedDistortion * 4;
                ctx.filter = `blur(${Math.random() * blur / 2}px) contrast(${1 + Math.random()})`;
              }
              break;
          }
          
          // Apply transforms
          ctx.translate(xPos, yPos);
          ctx.rotate(rotationAngle);
          ctx.scale(1 + progress * 0.2, 1 + progress * 0.2);
          
          // Draw text
          const adjustedFontSize = fontSize * responsiveScale;
          ctx.font = `${adjustedFontSize}px ${fontType}`;
          ctx.fillText(text, 0, 0);
          
          ctx.restore();
        }
        
        requestAnimationFrame(animate);
      }
      
      // Function to generate preset code
      function generatePresetCode(preset) {
        return JSON.stringify(preset);
      }
      
      // Function to generate embeddable code
      function generateEmbeddableCode() {
        const settings = getCurrentSettings();
        const codeObj = {
          type: "TYPOGRAPHY_PRESET",
          version: "1.0",
          preset: {
            name: presetNameInput.value.trim() || "Unnamed Preset",
            settings: settings
          }
        };
        
        // Format as JavaScript code that can be pasted directly into source
        const presetStr = JSON.stringify(codeObj.preset, null, 2);
        return `
// -------- Typography Preset Code --------
// Add this to the builtinPresets array in your source code
const customPreset = ${presetStr};
// builtinPresets.push(customPreset);
// ----------------------------------------
`;
      }
      
      // Function to create preset element
      function createPresetElement(preset, isBuiltin = false) {
        const presetItem = document.createElement('div');
        presetItem.className = 'preset-item';
        
        const presetName = document.createElement('span');
        presetName.textContent = preset.name;
        presetItem.appendChild(presetName);
        
        const presetActions = document.createElement('div');
        presetActions.className = 'preset-actions';
        
        const loadBtn = document.createElement('button');
        loadBtn.textContent = 'Load';
        loadBtn.addEventListener('click', () => {
          applySettings(preset.settings);
          showNotification(`Loaded preset: ${preset.name}`);
        });
        presetActions.appendChild(loadBtn);
        
        if (!isBuiltin) {
          const deleteBtn = document.createElement('button');
          deleteBtn.textContent = 'Delete';
          deleteBtn.addEventListener('click', () => {
            userPresets = userPresets.filter(p => p.name !== preset.name);
            localStorage.setItem('typographyPresets', JSON.stringify(userPresets));
            renderUserPresets();
            showNotification(`Deleted preset: ${preset.name}`);
          });
          presetActions.appendChild(deleteBtn);
        }
        
        const codeBtn = document.createElement('button');
        codeBtn.textContent = 'Code';
        codeBtn.addEventListener('click', () => {
          // Save the preset name for code generation
          presetNameInput.value = preset.name;
          presetCodeTextarea.value = generateEmbeddableCode();
          showNotification(`Generated code for preset: ${preset.name}`);
        });
        presetActions.appendChild(codeBtn);
        
        presetItem.appendChild(presetActions);
        return presetItem;
      }
      
      // Function to render user presets
      function renderUserPresets() {
        userPresetList.innerHTML = '';
        
        if (userPresets.length === 0) {
          const emptyMessage = document.createElement('div');
          emptyMessage.textContent = 'No saved presets yet';
          emptyMessage.style.padding = '5px';
          emptyMessage.style.opacity = '0.7';
          userPresetList.appendChild(emptyMessage);
          return;
        }
        
        userPresets.forEach(preset => {
          const presetElement = createPresetElement(preset);
          userPresetList.appendChild(presetElement);
        });
      }
      
      // Function to render builtin presets
      function renderBuiltinPresets() {
        builtinPresetList.innerHTML = '';
        
        builtinPresets.forEach(preset => {
          const presetElement = createPresetElement(preset, true);
          builtinPresetList.appendChild(presetElement);
        });
      }
      
      // Initialize preset lists
      renderUserPresets();
      renderBuiltinPresets();
      
      // Toggle preset panel
      togglePresetPanel.addEventListener('click', () => {
        presetPanel.classList.toggle('open');
      });
      
      // Save current settings as preset
      saveCurrentBtn.addEventListener('click', () => {
        const presetName = presetNameInput.value.trim();
        if (!presetName) {
          showNotification('Please enter a preset name');
          return;
        }
        
        // Check if name already exists
        const existingIndex = userPresets.findIndex(p => p.name === presetName);
        
        const newPreset = {
          name: presetName,
          settings: getCurrentSettings()
        };
        
        if (existingIndex >= 0) {
          // Update existing preset
          userPresets[existingIndex] = newPreset;
          showNotification(`Updated preset: ${presetName}`);
        } else {
          // Add new preset
          userPresets.push(newPreset);
          showNotification(`Saved preset: ${presetName}`);
        }
        
        localStorage.setItem('typographyPresets', JSON.stringify(userPresets));
        renderUserPresets();
        presetNameInput.value = '';
      });
      
      // Generate code for current settings
      generateCodeBtn.addEventListener('click', () => {
        const presetName = presetNameInput.value.trim() || 'Unnamed Preset';
        
        // Generate embeddable code instead of just the JSON
        presetCodeTextarea.value = generateEmbeddableCode();
        presetCodeTextarea.select();
        showNotification('Code generated! Copy to paste into source');
      });
      
      // Export preset
      exportPresetBtn.addEventListener('click', () => {
        const presetName = presetNameInput.value.trim() || 'Exported Preset';
        
        const preset = {
          name: presetName,
          settings: getCurrentSettings()
        };
        
        presetCodeTextarea.value = generatePresetCode(preset);
        presetCodeTextarea.select();
        document.execCommand('copy');
        showNotification('Preset code copied to clipboard!');
      });
      
      // Import preset
      importPresetBtn.addEventListener('click', () => {
        const code = presetCodeTextarea.value.trim();
        if (!code) {
          showNotification('Please enter preset code');
          return;
        }
        
        try {
          // Try to parse as direct JSON first
          let preset;
          
          try {
            preset = JSON.parse(code);
          } catch (e) {
            // If that fails, try to extract JSON from embedded code format
            const jsonMatch = code.match(/const\s+customPreset\s+=\s+({[\s\S]*?});/);
            if (jsonMatch && jsonMatch[1]) {
              preset = JSON.parse(jsonMatch[1]);
            } else {
              throw new Error('Could not parse preset code');
            }
          }
          
          if (!preset.name || !preset.settings) {
            throw new Error('Invalid preset format');
          }
          
          applySettings(preset.settings);
          showNotification(`Imported preset: ${preset.name}`);
          
          // Ask if user wants to save this imported preset
          if (confirm(`Do you want to save the imported preset "${preset.name}" to your collection?`)) {
            const existingIndex = userPresets.findIndex(p => p.name === preset.name);
            
            if (existingIndex >= 0) {
              // Update existing preset
              userPresets[existingIndex] = preset;
            } else {
              // Add new preset
              userPresets.push(preset);
            }
            
            localStorage.setItem('typographyPresets', JSON.stringify(userPresets));
            renderUserPresets();
          }
          
          presetCodeTextarea.value = '';
        } catch (error) {
          showNotification('Invalid preset code');
          console.error(error);
        }
      });
      
      // Save preset button in the main controls
      savePresetBtn.addEventListener('click', () => {
        presetPanel.classList.add('open');
        presetNameInput.focus();
      });
      
      // Handle control changes
      textInput.addEventListener('input', () => text = textInput.value);
      fontSizeControl.addEventListener('input', () => {
        targetFontSize = parseInt(fontSizeControl.value);
        if (!isInterpolating) fontSize = targetFontSize;
      });
      duplicationsControl.addEventListener('input', () => {
        targetDuplications = parseInt(duplicationsControl.value);
        if (!isInterpolating) duplications = targetDuplications;
      });
      blurControl.addEventListener('input', () => {
        targetBlur = parseInt(blurControl.value);
        if (!isInterpolating) blur = targetBlur;
      });
      rotationSpeedControl.addEventListener('input', () => {
        targetRotationSpeed = parseFloat(rotationSpeedControl.value);
        if (!isInterpolating) rotationSpeed = targetRotationSpeed;
      });
      distortionControl.addEventListener('input', () => {
        targetDistortion = parseInt(distortionControl.value);
        if (!isInterpolating) distortion = targetDistortion;
      });
      primaryColorControl.addEventListener('input', () => {
        targetPrimaryColor = primaryColorControl.value;
        if (!isInterpolating) primaryColor = targetPrimaryColor;
      });
      secondaryColorControl.addEventListener('input', () => {
        targetSecondaryColor = secondaryColorControl.value;
        if (!isInterpolating) secondaryColor = targetSecondaryColor;
      });
      effectTypeControl.addEventListener('change', () => {
        targetEffectType = effectTypeControl.value;
        if (!isInterpolating) effectType = targetEffectType;
      });
      fontTypeControl.addEventListener('change', () => {
        targetFontType = fontTypeControl.value;
        if (!isInterpolating) fontType = targetFontType;
      });
      transitionTimeControl.addEventListener('input', () => {
        transitionTime = parseFloat(transitionTimeControl.value);
        interpolationDuration = transitionTime * 1000;
      });
      
      // Randomize settings
      randomizeBtn.addEventListener('click', () => {
        // Save previous values
        prevFontSize = fontSize;
        prevDuplications = duplications;
        prevBlur = blur;
        prevRotationSpeed = rotationSpeed;
        prevDistortion = distortion;
        prevPrimaryColor = primaryColor;
        prevSecondaryColor = secondaryColor;
        prevEffectType = effectType;
        prevFontType = fontType;
        
        // Generate new random target values
        fontSizeControl.value = Math.floor(Math.random() * 350 + 50);
        duplicationsControl.value = Math.floor(Math.random() * 9 + 1);
        blurControl.value = Math.floor(Math.random() * 50);
        rotationSpeedControl.value = Math.floor(Math.random() * 10 + 1);
        distortionControl.value = Math.floor(Math.random() * 1000);
        
        // Random effect and font
        const effects = ['wave', 'fracture', 'spiral', 'glitch'];
        
        effectTypeControl.value = effects[Math.floor(Math.random() * effects.length)];
        
        // Set target values
        targetFontSize = parseInt(fontSizeControl.value);
        targetDuplications = parseInt(duplicationsControl.value);
        targetBlur = parseInt(blurControl.value);
        targetRotationSpeed = parseFloat(rotationSpeedControl.value);
        targetDistortion = parseInt(distortionControl.value);
        targetEffectType = effectTypeControl.value;
        
        // Start interpolation
        isInterpolating = true;
        interpolationStartTime = Date.now();
      });
      
      // Start animation
      animate();
    });
  </script>
</body>
</html>