<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TYPO_001 Experiment</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Alfa+Slab+One&family=Bebas+Neue&family=Cinzel:wght@700&family=Comfortaa:wght@700&family=DM+Serif+Display&family=Faster+One&family=Permanent+Marker&family=Righteous&family=Rubik+Glitch&family=Russo+One&family=Special+Elite&family=VT323&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Doto:wght,ROND@200,4&family=Offside&family=Rubik+Puddles&family=Silkscreen&family=Tulpen+One&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: monospace;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      height: 100vh;
      width: 100vw;
      cursor: crosshair;
    }

    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #feedback-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1; /* Behind the main canvas */
    }

    #typography-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* New styles for the feedback canvas */
    #feedback-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1; /* Behind the main canvas */
    }

    /* Add feedback effect controls to existing controls */
    .control-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 8px;
      backdrop-filter: blur(5px);
      z-index: 100;
      opacity: 0.3;
      transition: all 0.3s ease;
      transform: translateX(0);
    }

    .controls:hover {
      opacity: 1;
    }

    .controls.hidden {
      transform: translateX(calc(100% + 20px));
    }

    .toggle-controls-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 101;
      border: 1px solid #444;
      font-weight: bold;
      font-size: 18px;
      opacity: 0.5;
      transition: opacity 0.3s ease;
    }

    .toggle-controls-panel:hover {
      background: rgba(50, 50, 50, 0.7);
      opacity: 1;
    }

    .toggle-controls-panel.panel-hidden {
      right: 20px;
    }

    .control-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .control-label {
      font-size: 12px;
      width: 120px;
    }

    input[type="range"] {
      width: 120px;
      background: transparent;
    }

    input[type="color"] {
      width: 30px;
      height: 30px;
      border: none;
      background: none;
      cursor: pointer;
    }

    select, button {
      background: rgba(30, 30, 30, 0.8);
      color: #fff;
      border: 1px solid #555;
      padding: 5px;
      border-radius: 4px;
      cursor: pointer;
    }

    button {
      width: 100%;
      margin-top: 5px;
      transition: background 0.3s ease;
    }

    button:hover {
      background: rgba(60, 60, 60, 0.8);
    }

    .text-input {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
      padding: 10px;
      border-radius: 8px;
      z-index: 100;
      opacity: 0.3;
      transition: opacity 0.3s ease;
    }

    .text-input:hover {
      opacity: 1;
    }

    #text-content {
      background: rgba(30, 30, 30, 0.8);
      color: #fff;
      border: 1px solid #555;
      padding: 5px;
      border-radius: 4px;
      width: 200px;
    }

    /* Preset System Styles */
    .preset-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(5px);
      padding: 15px;
      border-radius: 8px;
      z-index: 100;
      width: 300px;
      max-height: 80vh;
      overflow-y: auto;
      transform: translateX(320px);
      transition: transform 0.3s ease;
    }

    .preset-panel.open {
      transform: translateX(0);
    }

    .preset-panel h3 {
      margin-bottom: 10px;
      font-size: 16px;
    }

    .preset-list {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin-bottom: 15px;
      max-height: 200px;
      overflow-y: auto;
    }

    .preset-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px;
      border: 1px solid #333;
      border-radius: 4px;
    }

    .preset-item:hover {
      background: rgba(60, 60, 60, 0.5);
    }

    .preset-actions {
      display: flex;
      gap: 5px;
    }

    .preset-actions button {
      width: auto;
      padding: 2px 5px;
      margin: 0;
      font-size: 11px;
    }

    #preset-name {
      width: 100%;
      margin-bottom: 10px;
      background: rgba(30, 30, 30, 0.8);
      color: #fff;
      border: 1px solid #555;
      padding: 5px;
      border-radius: 4px;
    }

    #preset-code {
      width: 100%;
      height: 100px;
      margin-top: 10px;
      background: rgba(30, 30, 30, 0.8);
      color: #fff;
      border: 1px solid #555;
      padding: 5px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 11px;
      resize: vertical;
    }

    .preset-buttons {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .preset-buttons button {
      flex: 1;
    }

    .toggle-preset-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 101;
      border: 1px solid #444;
      font-weight: bold;
      font-size: 18px;
    }

    .toggle-preset-panel:hover {
      background: rgba(50, 50, 50, 0.7);
    }

    .notification {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 4px;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .notification.show {
      opacity: 1;
    }

    /* Built-in presets section */
    .preset-category {
      margin-bottom: 15px;
    }

    .preset-category h4 {
      margin-bottom: 5px;
      font-size: 14px;
      color: #aaa;
      border-bottom: 1px solid #333;
      padding-bottom: 3px;
    }

    .font-heading {
      margin-top: 10px;
      margin-bottom: 2px;
      font-size: 12px;
      color: #aaa;
      opacity: 0.8;
    }

    .font-preview {
      display: inline-block;
      margin-left: 10px;
      font-size: 14px;
      opacity: 0.8;
    }

    .menu-container {
      position: fixed;
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 100;
    }

    .main-menu ul {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 20px;
      transition: all 0.4s ease;
    }

    .main-menu li {
      position: relative;
      transition: all 0.4s ease;
    }

    .menu-item {
      color: #ffff00; /* Yellow text color */
      font-size: 18px;
      text-decoration: none;
      transition: all 0.4s ease;
      font-family: monospace;
      opacity: 0.9;
      display: inline-block;
    }

    .menu-item:hover {
      opacity: 0.6;
      cursor: pointer;
    }
    
    .menu-item.active {
      font-size: 24px;
      font-weight: bold;
      opacity: 1;
      transform: translateX(5px);
    }
    
    /* Push items away from active item */
    li.active-item ~ li {
      transform: translateY(8px);
    }
    
    li:not(.active-item) + li.active-item ~ li {
      transform: translateY(8px);
    }
    
    /* Media query for responsive design */
    @media (max-width: 768px) {
      .menu-container {
        top: auto;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
      }

      .main-menu ul {
        flex-direction: row;
        justify-content: center;
        gap: 15px;
      }
      
      .menu-item.active {
        transform: translateY(-5px);
      }
      
      li.active-item ~ li {
        transform: translateX(8px);
      }
      
      li:not(.active-item) + li.active-item ~ li {
        transform: translateX(8px);
      }
    }
  </style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="feedback-canvas"></canvas>
    <canvas id="typography-canvas"></canvas>
  </div>
  <div class="text-input">
    <input type="text" id="text-content" placeholder="Type something..." value="EN5EMBLE">
  </div>
  <div class="menu-container">
    <nav class="main-menu">
      <ul>
        <li><a href="#events" class="menu-item" data-section="events">events</a></li>
        <li><a href="#mixes" class="menu-item" data-section="mixes">mixes</a></li>
        <li><a href="#archives" class="menu-item" data-section="archives">archives</a></li>
        <li><a href="#contact" class="menu-item" data-section="contact">contact</a></li>
      </ul>
    </nav>
  </div>
  <div class="toggle-controls-panel">C</div>
  <div class="controls">
    <div class="control-group">
      <span class="control-label">Font Size</span>
      <input type="range" id="font-size" min="50" max="400" value="138">
    </div>
    <div class="control-group">
      <span class="control-label">Duplications</span>
      <input type="range" id="duplications" min="1" max="20" value="20">
    </div>
    <div class="control-group">
      <span class="control-label">Blur Intensity</span>
      <input type="range" id="blur" min="0" max="50" value="50">
    </div>
    <div class="control-group">
      <span class="control-label">Rotation Speed</span>
      <input type="range" id="rotation-speed" min="0" max="10" value="0">
    </div>
    <div class="control-group">
      <span class="control-label">Distortion</span>
      <input type="range" id="distortion" min="0" max="1000" value="1000">
    </div>
    <div class="control-group">
      <span class="control-label">Primary Color</span>
      <input type="color" id="primary-color" value="#ffffff">
    </div>
    <div class="control-group">
      <span class="control-label">Secondary Color</span>
      <input type="color" id="secondary-color" value="#ffffff">
    </div>
    <div class="control-group">
      <span class="control-label">Effect Type</span>
      <select id="effect-type">
        <option value="glitch">Glitch</option>
        <option value="wave">Wave</option>
        <option value="fracture">Fracture</option>
        <option value="spiral">Spiral</option>
      </select>
    </div>
    <div class="control-group">
      <span class="control-label">Font Type</span>
      <select id="font-type">
        <option value="sans-serif">Sans-serif</option>
        <option value="serif">Serif</option>
        <option value="monospace">Monospace</option>
      </select>
    </div>
    <div class="control-group">
      <span class="control-label">Trail Effect</span>
      <input type="checkbox" id="feedback-enabled" checked>
    </div>
    <div class="control-group">
      <span class="control-label">Trail Decay</span>
      <input type="range" id="feedback-decay" min="0.1" max="0.9" step="0.01" value="0.5">
    </div>
    <div class="control-group">
      <span class="control-label">Trail Opacity</span>
      <input type="range" id="feedback-opacity" min="0.05" max="0.6" step="0.01" value="0.1">
    </div>
    <div class="control-group">
      <span class="control-label">Trail Zoom</span>
      <input type="range" id="feedback-zoom" min="0.8" max="1.2" step="0.001" value="0.95">
    </div>
    <div class="control-group">
      <span class="control-label">Trail Shift X</span>
      <input type="range" id="feedback-shift-x" min="-50" max="50" step="0.5" value="0">
    </div>
    <div class="control-group">
      <span class="control-label">Trail Shift Y</span>
      <input type="range" id="feedback-shift-y" min="-50" max="50" step="0.5" value="0">
    </div>
    <!-- Transition time control -->
    <div class="control-group">
      <span class="control-label">Transition Time</span>
      <input type="range" id="transition-time" min="0.01" max="0.5" step="0.01" value="0.1">
    </div>
    <button id="randomize">Randomize</button>
    <button id="save-preset-btn">Save Preset</button>
  </div>

  <!-- Preset Toggle Button -->
  <div class="toggle-preset-panel">P</div>

  <!-- Preset Panel -->
  <div class="preset-panel">
    <h3>TYPO_001 Presets</h3>
    
    <!-- Built-in Presets -->
    <div class="preset-category">
      <h4>Built-in Presets</h4>
      <div class="preset-list" id="builtin-preset-list">
        <!-- Built-in presets will be loaded here -->
      </div>
    </div>
    
    <!-- User Presets -->
    <div class="preset-category">
      <h4>Your Presets</h4>
      <div class="preset-list" id="user-preset-list">
        <!-- User presets will be loaded here -->
      </div>
    </div>
    
    <!-- Save New Preset Form -->
    <h4>Create New Preset</h4>
    <input type="text" id="preset-name" placeholder="Preset Name">
    <div class="preset-buttons">
      <button id="save-current">Save Current</button>
      <button id="generate-code">Generate Code</button>
    </div>
    
    <!-- Import/Export -->
    <h4>Import/Export</h4>
    <textarea id="preset-code" placeholder="Paste preset code here to import"></textarea>
    <div class="preset-buttons">
      <button id="import-preset">Import</button>
      <button id="export-preset">Export Current</button>
    </div>
  </div>

  <!-- Notification -->
  <div class="notification" id="notification"></div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Elements
      const canvas = document.getElementById('typography-canvas');
      const ctx = canvas.getContext('2d');
      const feedbackCanvas = document.getElementById('feedback-canvas');
      const feedbackCtx = feedbackCanvas.getContext('2d');
      
      const textInput = document.getElementById('text-content');
      
      // Controls
      const fontSizeControl = document.getElementById('font-size') || { value: 138, addEventListener: () => {} };
      const duplicationsControl = document.getElementById('duplications') || { value: 20, addEventListener: () => {} };
      const blurControl = document.getElementById('blur') || { value: 50, addEventListener: () => {} };
      const rotationSpeedControl = document.getElementById('rotation-speed') || { value: 0, addEventListener: () => {} };
      const distortionControl = document.getElementById('distortion') || { value: 1000, addEventListener: () => {} };
      const primaryColorControl = document.getElementById('primary-color') || { value: "#ffffff", addEventListener: () => {} };
      const secondaryColorControl = document.getElementById('secondary-color') || { value: "#ffffff", addEventListener: () => {} };
      const effectTypeControl = document.getElementById('effect-type') || { value: "glitch", addEventListener: () => {} };
      const fontTypeControl = document.getElementById('font-type') || { value: "sans-serif", addEventListener: () => {} };
      const transitionTimeControl = document.getElementById('transition-time') || { value: 0.1, addEventListener: () => {} };
      const randomizeBtn = document.getElementById('randomize');
      // feedback effect controls
      const feedbackEnabledControl = document.getElementById('feedback-enabled');
      const feedbackDecayControl = document.getElementById('feedback-decay');
      const feedbackOpacityControl = document.getElementById('feedback-opacity');
      const feedbackZoomControl = document.getElementById('feedback-zoom');
      const feedbackShiftXControl = document.getElementById('feedback-shift-x');
      const feedbackShiftYControl = document.getElementById('feedback-shift-y');
      
      // Preset Controls
      const togglePresetPanel = document.querySelector('.toggle-preset-panel');
      const presetPanel = document.querySelector('.preset-panel');
      const userPresetList = document.getElementById('user-preset-list');
      const builtinPresetList = document.getElementById('builtin-preset-list');
      const presetNameInput = document.getElementById('preset-name');
      const saveCurrentBtn = document.getElementById('save-current');
      const generateCodeBtn = document.getElementById('generate-code');
      const importPresetBtn = document.getElementById('import-preset');
      const exportPresetBtn = document.getElementById('export-preset');
      const presetCodeTextarea = document.getElementById('preset-code');
      const savePresetBtn = document.getElementById('save-preset-btn');
      const notification = document.getElementById('notification');

      const mobileFontScaleFactor = 0.5;

      // THEN define the validateControls function after all the controls are defined
      function validateControls() {
        const requiredControls = [
          { id: 'font-size', element: fontSizeControl },
          { id: 'duplications', element: duplicationsControl },
          { id: 'blur', element: blurControl },
          { id: 'rotation-speed', element: rotationSpeedControl },
          { id: 'distortion', element: distortionControl },
          { id: 'primary-color', element: primaryColorControl },
          { id: 'secondary-color', element: secondaryColorControl },
          { id: 'effect-type', element: effectTypeControl },
          { id: 'font-type', element: fontTypeControl }
        ];
        
        const missingControls = requiredControls.filter(control => !control.element);
        if (missingControls.length > 0) {
          missingControls.forEach(control => {
            console.error(`Missing required control element: #${control.id}`);
          });
          console.warn(`Found ${missingControls.length} missing controls. App may not function correctly.`);
        }
        
        return missingControls.length === 0;
      }

      // NOW call validateControls after it's defined and after the controls are defined
      const controlsValid = validateControls();

      // State - with fallbacks for each value
      let text = textInput ? textInput.value : 'EN5EMBLE';
      let fontSize = fontSizeControl && fontSizeControl.value ? parseInt(fontSizeControl.value) : 138;
      let duplications = duplicationsControl && duplicationsControl.value ? parseInt(duplicationsControl.value) : 20;
      let blur = blurControl && blurControl.value ? parseInt(blurControl.value) : 50;
      let rotationSpeed = rotationSpeedControl && rotationSpeedControl.value ? parseFloat(rotationSpeedControl.value) : 0;
      let distortion = distortionControl && distortionControl.value ? parseInt(distortionControl.value) : 1000;
      let primaryColor = primaryColorControl && primaryColorControl.value ? primaryColorControl.value : '#ffffff';
      let secondaryColor = secondaryColorControl && secondaryColorControl.value ? secondaryColorControl.value : '#ffffff';
      let effectType = effectTypeControl && effectTypeControl.value ? effectTypeControl.value : 'glitch';
      let fontType = fontTypeControl && fontTypeControl.value ? fontTypeControl.value : 'sans-serif';
      let feedbackEnabled = feedbackEnabledControl.checked;
      let feedbackDecay = parseFloat(feedbackDecayControl.value);
      let feedbackOpacity = parseFloat(feedbackOpacityControl.value);
      let feedbackZoom = parseFloat(feedbackZoomControl.value);
      let feedbackShiftX = parseFloat(feedbackShiftXControl.value);
      let feedbackShiftY = parseFloat(feedbackShiftYControl.value);
      let transitionTime = transitionTimeControl && transitionTimeControl.value ? parseFloat(transitionTimeControl.value) : 0.1;
      
      // Target values for interpolation
      let targetFontSize = fontSize;
      let targetDuplications = duplications;
      let targetBlur = blur;
      let targetRotationSpeed = rotationSpeed;
      let targetDistortion = distortion;
      let targetPrimaryColor = primaryColor;
      let targetSecondaryColor = secondaryColor;
      let targetEffectType = effectType;
      let targetFontType = fontType;
      
      // Interpolation state
      let isInterpolating = false;
      let interpolationStartTime = 0;
      let interpolationDuration = transitionTime * 1000; // in milliseconds
      
      // Previous values for interpolation
      let prevFontSize = fontSize;
      let prevDuplications = duplications;
      let prevBlur = blur;
      let prevRotationSpeed = rotationSpeed;
      let prevDistortion = distortion;
      let prevPrimaryColor = primaryColor;
      let prevSecondaryColor = secondaryColor;
      let prevEffectType = effectType;
      let prevFontType = fontType;
      
      // Mouse position for interactive effects
      let mouseX = 0;
      let mouseY = 0;
      
      // Animation variables
      let time = 0;
      let isAnimating = true;
      
      // User presets storage
      let userPresets = JSON.parse(localStorage.getItem('typographyPresets')) || [];

      // Variables for feedback processing
      let frameCount = 0;

      const fontSystem = {
        // Maps display names to actual CSS font families
        fontMap: {
          // Standard fonts (maintaining backward compatibility)
          "sans-serif": "sans-serif",
          "serif": "serif", 
          "monospace": "monospace",

          // Display fonts
          "Alfa Slab": "'Alfa Slab One', sans-serif",
          "Cinzel": "'Cinzel', serif",

          //Creative fonts
          "Silkscreen": "'Silkscreen', sans-serif",
          "Offside": "'Offside', sans-serif",
          "Tulpen One": "'Tulpen One', sans-serif",
          "Doto": "'Doto', sans-serif"
        },
        
        // Categories for organization
        categories: {
          "Standard": ["sans-serif", "serif", "monospace"],
          "Display": ["Alfa Slab", "Cinzel"],
          "Creative": ["Silkscreen", "Offside", "Tulpen One", "Doto"]
        },
        
        // Get actual font family from selection name
        getFontFamily(fontName) {
          return this.fontMap[fontName] || fontName;
        },
        
        // Ensure backward compatibility with old presets
        getCompatibleFontName(fontFamily) {
          // If it's a direct match, return it
          if (this.fontMap[fontFamily]) {
            return fontFamily;
          }
          
          // Look for the font family in the values
          for (const [key, value] of Object.entries(this.fontMap)) {
            if (value === fontFamily) {
              return key;
            }
          }
          
          // Default fallback
          return "sans-serif";
        },
        
        // Preload fonts to prevent FOUC (Flash of Unstyled Content)
        preloadFonts() {
          const preloadDiv = document.createElement('div');
          preloadDiv.style.opacity = '0';
          preloadDiv.style.position = 'absolute';
          preloadDiv.style.top = '-9999px';
          
          // Create a span for each font
          for (const fontFamily of Object.values(this.fontMap)) {
            const span = document.createElement('span');
            span.style.fontFamily = fontFamily;
            span.textContent = 'abcdefghijklmnopqrstuvwxyz0123456789';
            preloadDiv.appendChild(span);
          }
          
          document.body.appendChild(preloadDiv);
          
          // Remove after a delay to ensure fonts are loaded
          setTimeout(() => {
            document.body.removeChild(preloadDiv);
          }, 3000);
        }
      };

      // Replace your populateFontSelector function with this fixed version:
      function populateFontSelector() {
        const fontTypeSelect = document.getElementById('font-type');
        if (!fontTypeSelect) {
          console.error('Font type select element not found!');
          return;
        }
        
        fontTypeSelect.innerHTML = ''; // Clear existing options
        
        // Add each category and its fonts
        for (const [category, fonts] of Object.entries(fontSystem.categories)) {
          // Add category group
          const groupElement = document.createElement('optgroup');
          groupElement.label = category;
          
          // Add fonts in this category
          fonts.forEach(fontName => {
            const option = document.createElement('option');
            option.value = fontName;
            option.textContent = fontName;
            option.style.fontFamily = fontSystem.getFontFamily(fontName);
            
            // Set default selection for the first standard font (sans-serif)
            if (fontName === 'sans-serif') {
              option.selected = true;
            }
            
            groupElement.appendChild(option);
          });
          
          fontTypeSelect.appendChild(groupElement);
        }
        
        // Update the select styling to show the actual font
        fontTypeSelect.addEventListener('change', function() {
          if (this.value) {
            this.style.fontFamily = fontSystem.getFontFamily(this.value);
          }
        });
        
        // Set initial style with safety check
        try {
          if (fontTypeSelect.options.length > 0) {
            // Ensure a value exists by forcing selection of first option if none selected
            if (!fontTypeSelect.value) {
              fontTypeSelect.selectedIndex = 0;
            }
            fontTypeSelect.style.fontFamily = fontSystem.getFontFamily(fontTypeSelect.value);
          } else {
            // Fallback if somehow we have no options
            fontTypeSelect.style.fontFamily = 'sans-serif';
          }
        } catch (e) {
          console.error('Error setting initial font style:', e);
          // Fallback to a safe default
          fontTypeSelect.style.fontFamily = 'sans-serif';
        }
      }

      // Make it available globally if needed
      window.fontSystem = fontSystem;
      
      // Only then initialize the font selector
      populateFontSelector();
      
      // And finally, preload fonts
      fontSystem.preloadFonts();

      let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      let hasGyro = false;
      let gyroData = { beta: 0, gamma: 0 };

      // Built-in presets
      const builtinPresets = [
        {
          name: "Unsure",
          settings: {
            fontSize: 138,
            duplications: 20,
            blur: 50,
            rotationSpeed: 0,
            distortion: 1000,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "glitch",
            fontType: "sans-serif",
            feedbackEnabled: false,
            feedbackDecay: 0.6,
            feedbackOpacity: 0.1,
            feedbackZoom: 0.98,
            feedbackShiftX: 0,
            feedbackShiftY: 0
          }
        },
        {
          name: "Beacon of truth",
          settings: {
            fontSize: 50,
            duplications: 20,
            blur: 0,
            rotationSpeed: 3,
            distortion: 390,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "wave",
            fontType: "monospace",
            feedbackEnabled: true,
            feedbackDecay: 0.9,
            feedbackOpacity: 0.41,
            feedbackZoom: 0.93,
            feedbackShiftX: 0,
            feedbackShiftY: 0
          }
        },
        {
            name: "Skeud",
            settings: {
            fontSize: 168,
            duplications: 9,
            blur: 0,
            rotationSpeed: 5,
            distortion: 0,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "spiral",
            fontType: "serif",
            feedbackDecay: 0.75,
            feedbackOpacity: 0.15,
            feedbackZoom: 1.2,
            feedbackShiftX: 0,
            feedbackShiftY: 0
        }
        },
        {
            name: "Arabesque",
            settings: {
            fontSize: 400,
            duplications: 9,
            blur: 2,
            rotationSpeed: 9,
            distortion: 0,
            primaryColor: "#ffffff",
            secondaryColor: "#000000",
            effectType: "spiral",
            fontType: "serif",
            feedbackEnabled: false,
            feedbackDecay: 0.6,
            feedbackOpacity: 0.1,
            feedbackZoom: 0.98,
            feedbackShiftX: 0,
            feedbackShiftY: 0
        }
        },
        {
            name: "Wall",
            settings: {
            fontSize: 75,
            duplications: 20,
            blur: 0,
            rotationSpeed: 0,
            distortion: 390,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "wave",
            fontType: "monospace",
            feedbackEnabled: true,
            feedbackDecay: 0.77,
            feedbackOpacity: 0.57,
            feedbackZoom: 0.8,
            feedbackShiftX: -4,
            feedbackShiftY: -16.5
        }
        }
      ];

      // Set canvas dimensions
      function setCanvasDimensions() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Set dimensions for feedback canvas
        feedbackCanvas.width = window.innerWidth;
        feedbackCanvas.height = window.innerHeight;
        
      }
      
      setCanvasDimensions();

     // First, remove any existing toggle buttons to prevent duplicates
    const existingToggleButtons = document.querySelectorAll('.toggle-controls-panel');
    existingToggleButtons.forEach(button => {
      if (button) button.remove();
    });

    // Get control elements
    const controlsPanel = document.querySelector('.controls');

    // Create a single toggle button
    const toggleControlsBtn = document.createElement('div');
    toggleControlsBtn.className = 'toggle-controls-panel';
    toggleControlsBtn.textContent = 'C';
    document.body.appendChild(toggleControlsBtn);

    // Update toggle button position based on panel state
    function updateTogglePosition() {
      if (controlsPanel.classList.contains('hidden')) {
        toggleControlsBtn.style.right = '20px';
      } else {
        const controlsWidth = controlsPanel.offsetWidth;
        toggleControlsBtn.style.right = (controlsWidth + 30) + 'px';
      }
    }

    // Initial positioning
    // updateTogglePosition();

    // Toggle controls panel
    toggleControlsBtn.addEventListener('click', () => {
      controlsPanel.classList.toggle('hidden');
      toggleControlsBtn.classList.toggle('panel-hidden');
      updateTogglePosition();
      
      // Save the state to localStorage
      localStorage.setItem('controlsPanelHidden', controlsPanel.classList.contains('hidden'));
    });

    // Check if the controls panel was hidden in the previous session
    const wasPanelHidden = localStorage.getItem('controlsPanelHidden') === 'true';
    if (wasPanelHidden) {
      controlsPanel.classList.add('hidden');
      toggleControlsBtn.classList.add('panel-hidden');
    } else {
      // If not hidden, position the toggle button correctly on load
      // window.addEventListener('load', () => {
      //   updateTogglePosition();
      // });
    }

      window.addEventListener('resize', () => {
        setCanvasDimensions();
        updateTogglePosition();
      });

      // Mouse move event
      window.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      if (isMobile) {
        // Create a button to request permission on iOS (required for iOS 13+)
        if (typeof DeviceOrientationEvent !== 'undefined' && 
            typeof DeviceOrientationEvent.requestPermission === 'function') {
          
          const permissionBtn = document.createElement('button');
          permissionBtn.textContent = 'Enable Gyroscope';
          permissionBtn.style.position = 'fixed';
          permissionBtn.style.top = '50%';
          permissionBtn.style.left = '50%';
          permissionBtn.style.transform = 'translate(-50%, -50%)';
          permissionBtn.style.zIndex = '1000';
          permissionBtn.style.padding = '12px 24px';
          permissionBtn.style.backgroundColor = '#333';
          permissionBtn.style.color = 'white';
          permissionBtn.style.border = 'none';
          permissionBtn.style.borderRadius = '4px';
          permissionBtn.style.fontSize = '16px';
          
          permissionBtn.addEventListener('click', () => {
            DeviceOrientationEvent.requestPermission()
              .then(response => {
                if (response === 'granted') {
                  window.addEventListener('deviceorientation', handleOrientation);
                  hasGyro = true;
                  document.body.removeChild(permissionBtn);
                  showNotification('Gyroscope enabled');
                }
              })
              .catch(console.error);
          });
          
          document.body.appendChild(permissionBtn);
        } else {
          // For non-iOS devices or older iOS versions
          window.addEventListener('deviceorientation', handleOrientation);
          hasGyro = true;
        }
      }

      function applyDefaultPreset() {
        // Apply the "Unsure" preset by default
        const unsurePreset = builtinPresets.find(preset => preset.name === "Unsure");
        if (unsurePreset) {
          applySettings(unsurePreset.settings);
          showNotification("Default preset 'Unsure' applied");
        }
      }

      // Call this after all your initialization
      applyDefaultPreset();

      // Handle orientation data
      function handleOrientation(event) {
        // Normalize gyroscope data
        gyroData.beta = event.beta;  // Front/back tilt: -180 to 180
        gyroData.gamma = event.gamma; // Left/right tilt: -90 to 90
      }                                    

      // Function to convert hex color to RGB array
      function hexToRgb(hex) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return [r, g, b];
      }
      
      // Function to convert RGB array to hex color
      function rgbToHex(r, g, b) {
        return `#${Math.floor(r).toString(16).padStart(2, '0')}${Math.floor(g).toString(16).padStart(2, '0')}${Math.floor(b).toString(16).padStart(2, '0')}`;
      }
      
      // Function to interpolate between two colors
      function interpolateColor(color1, color2, factor) {
        const rgb1 = hexToRgb(color1);
        const rgb2 = hexToRgb(color2);
        
        const r = rgb1[0] + factor * (rgb2[0] - rgb1[0]);
        const g = rgb1[1] + factor * (rgb2[1] - rgb1[1]);
        const b = rgb1[2] + factor * (rgb2[2] - rgb1[2]);
        
        return rgbToHex(r, g, b);
      }
      
      // Function to show notification
      function showNotification(message) {
        notification.textContent = message;
        notification.classList.add('show');
        setTimeout(() => {
          notification.classList.remove('show');
        }, 2000);
      }

      // Apply feedback effect
      function applyFeedback() {
        // Skip frames for performance if needed
        frameCount++;
        
        // Save current transformation state
        feedbackCtx.save();
        
        // Apply fade effect by drawing a semi-transparent black rectangle
        feedbackCtx.fillStyle = `rgba(0, 0, 0, ${feedbackDecay})`;
        feedbackCtx.fillRect(0, 0, feedbackCanvas.width, feedbackCanvas.height);
        
        // Set the composite operation to only show brighter parts
        feedbackCtx.globalCompositeOperation = 'lighter';
        
        // Calculate center for transformations
        const centerX = feedbackCanvas.width / 2;
        const centerY = feedbackCanvas.height / 2;
        
        // Apply transformations relative to center
        feedbackCtx.translate(centerX, centerY);
        feedbackCtx.scale(feedbackZoom, feedbackZoom);
        feedbackCtx.translate(-centerX + feedbackShiftX, -centerY + feedbackShiftY);
        
        // Draw the current canvas onto the feedback canvas with opacity
        feedbackCtx.globalAlpha = feedbackOpacity;
        feedbackCtx.drawImage(canvas, 0, 0);
        
        // Restore the context state
        feedbackCtx.restore();
      }
      
      // Function to get current settings
      function getCurrentSettings() {
        return {
          fontSize: parseInt(fontSizeControl.value),
          duplications: parseInt(duplicationsControl.value),
          blur: parseInt(blurControl.value),
          rotationSpeed: parseFloat(rotationSpeedControl.value),
          distortion: parseInt(distortionControl.value),
          primaryColor: primaryColorControl.value,
          secondaryColor: secondaryColorControl.value,
          effectType: effectTypeControl.value,
          fontType: fontTypeControl.value,
          feedbackEnabled: feedbackEnabledControl.checked,
          feedbackDecay: parseFloat(feedbackDecayControl.value),
          feedbackOpacity: parseFloat(feedbackOpacityControl.value),
          feedbackZoom: parseFloat(feedbackZoomControl.value),
          feedbackShiftX: parseFloat(feedbackShiftXControl.value),
          feedbackShiftY: parseFloat(feedbackShiftYControl.value),
        };
      }
      
      // Function to apply settings from a preset
      function applySettings(settings) {
        // Save previous values for interpolation
        prevFontSize = fontSize;
        prevDuplications = duplications;
        prevBlur = blur;
        prevRotationSpeed = rotationSpeed;
        prevDistortion = distortion;
        prevPrimaryColor = primaryColor;
        prevSecondaryColor = secondaryColor;
        prevEffectType = effectType;
        prevFontType = fontType;
        
        // Set the UI controls to new values
        fontSizeControl.value = settings.fontSize;
        duplicationsControl.value = settings.duplications;
        blurControl.value = settings.blur;
        rotationSpeedControl.value = settings.rotationSpeed;
        distortionControl.value = settings.distortion;
        primaryColorControl.value = settings.primaryColor;
        secondaryColorControl.value = settings.secondaryColor;
        effectTypeControl.value = settings.effectType;
        fontTypeControl.value = fontSystem.getCompatibleFontName(settings.fontType);
        
        // Set target values for interpolation
        targetFontSize = settings.fontSize;
        targetDuplications = settings.duplications;
        targetBlur = settings.blur;
        targetRotationSpeed = settings.rotationSpeed;
        targetDistortion = settings.distortion;
        targetPrimaryColor = settings.primaryColor;
        targetSecondaryColor = settings.secondaryColor;
        targetEffectType = settings.effectType;
        targetFontType = settings.fontType;

        // Apply feedback settings if they exist in the preset
        if (settings.feedbackEnabled !== undefined) {
          feedbackEnabledControl.checked = settings.feedbackEnabled;
          feedbackEnabled = settings.feedbackEnabled;
        }
        
        if (settings.feedbackDecay !== undefined) {
          feedbackDecayControl.value = settings.feedbackDecay;
          feedbackDecay = settings.feedbackDecay;
        }
        
        if (settings.feedbackOpacity !== undefined) {
          feedbackOpacityControl.value = settings.feedbackOpacity;
          feedbackOpacity = settings.feedbackOpacity;
        }
        
        if (settings.feedbackZoom !== undefined) {
          feedbackZoomControl.value = settings.feedbackZoom;
          feedbackZoom = settings.feedbackZoom;
        }
        
        if (settings.feedbackShiftX !== undefined) {
          feedbackShiftXControl.value = settings.feedbackShiftX;
          feedbackShiftX = settings.feedbackShiftX;
        }
        
        if (settings.feedbackShiftY !== undefined) {
          feedbackShiftYControl.value = settings.feedbackShiftY;
          feedbackShiftY = settings.feedbackShiftY;
        }

        if (feedbackCanvas && feedbackCtx) {
          feedbackCtx.clearRect(0, 0, feedbackCanvas.width, feedbackCanvas.height);
        }

        // Start interpolation
        isInterpolating = true;
        interpolationStartTime = Date.now();
      }
      
      // Animation function
      function animate() {
        if (!isAnimating) return;

        if (!canvas || !ctx) {
          console.error("Cannot animate: canvas or context is missing");
          isAnimating = false;
          return;
        }
              
        // Handle interpolation
        if (isInterpolating) {
          const currentTime = Date.now();
          const elapsed = currentTime - interpolationStartTime;
          let progress = Math.min(elapsed / interpolationDuration, 1);
          
          // Ease in-out function for smoother transitions
          progress = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;
          
          // Interpolate numeric values
          fontSize = Math.round(prevFontSize + (targetFontSize - prevFontSize) * progress);
          duplications = Math.round(prevDuplications + (targetDuplications - prevDuplications) * progress);
          blur = Math.round(prevBlur + (targetBlur - prevBlur) * progress);
          rotationSpeed = prevRotationSpeed + (targetRotationSpeed - prevRotationSpeed) * progress;
          distortion = Math.round(prevDistortion + (targetDistortion - prevDistortion) * progress);
          
          // Interpolate colors
          primaryColor = interpolateColor(prevPrimaryColor, targetPrimaryColor, progress);
          secondaryColor = interpolateColor(prevSecondaryColor, targetSecondaryColor, progress);
          
          // For effect type and font type, we switch immediately at the midpoint of interpolation
          if (progress >= 0.5) {
            effectType = targetEffectType;
            fontType = targetFontType;
          }
          
          // Update UI controls to reflect current interpolated values
          fontSizeControl.value = fontSize;
          duplicationsControl.value = duplications;
          blurControl.value = blur;
          rotationSpeedControl.value = rotationSpeed;
          distortionControl.value = distortion;
          primaryColorControl.value = primaryColor;
          secondaryColorControl.value = secondaryColor;
          
          // End interpolation when complete
          if (progress >= 1) {
            isInterpolating = false;
            effectType = targetEffectType;
            fontType = targetFontType;
          }
        }
        
        if (feedbackEnabled) {
          applyFeedback();
        }

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Update time
        time += 0.01 * rotationSpeed;
        
        // Apply canvas-level blur if needed
        if (blur > 0) {
          ctx.filter = `blur(${blur / 5}px)`;
        } else {
          ctx.filter = 'none';
        }
        
        // Calculate center position
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // Replace with this code:
        let inputX, inputY;

        if (isMobile && hasGyro) {
          // Use gyroscope data
          // Map gamma (-90 to 90) to canvas width with increased sensitivity for better effect
          inputX = centerX + (gyroData.gamma / 30) * centerX;
          // Map beta (-180 to 180) to canvas height with a limited range for better control
          inputY = centerY + (Math.max(-30, Math.min(30, gyroData.beta)) / 30) * centerY;
        } else {
          // Use mouse data on desktop
          inputX = mouseX;
          inputY = mouseY;
        }

        const inputInfluenceX = (inputX - centerX) / centerX * distortion;
        const inputInfluenceY = (inputY - centerY) / centerY * distortion;
        
        // Set text properties
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Draw each duplication
        for (let i = 0; i < duplications; i++) {
          const progress = i / duplications;
          const angle = time + progress * Math.PI * 2;
          
          // Color gradient based on progress
          const ratio = progress;
          const color = interpolateColor(primaryColor, secondaryColor, ratio);
          ctx.fillStyle = color;
          
          // Apply effect-specific transformations
          ctx.save();
          
          // Base position influenced by mouse
          let xPos = centerX + inputInfluenceX * Math.sin(progress * Math.PI * 2);
          let yPos = centerY + inputInfluenceY * Math.cos(progress * Math.PI * 2);
          
          let scaleFactor = 1;
          let rotationAngle = angle * rotationSpeed;
          
          switch (effectType) {
            case 'wave':
              xPos += Math.sin(time * 2 + progress * Math.PI * 4) * distortion;
              yPos += Math.cos(time * 2 + progress * Math.PI * 4) * distortion;
              break;
              
            case 'fracture':
              xPos += (Math.random() - 0.5) * distortion * 2;
              yPos += (Math.random() - 0.5) * distortion * 2;
              rotationAngle += (Math.random() - 0.5) * distortion / 100;
              break;
              
            case 'spiral':
              const spiralRadius = progress * distortion * 2;
              xPos += Math.cos(angle * 3) * spiralRadius;
              yPos += Math.sin(angle * 3) * spiralRadius;
              break;
              
            case 'glitch':
              if (Math.random() > 0.7) {
                xPos += (Math.random() - 0.5) * distortion * 4;
                ctx.filter = `blur(${Math.random() * blur / 2}px) contrast(${1 + Math.random()})`;
              }
              break;
          }
          
          // Apply transforms
          ctx.translate(xPos, yPos);
          ctx.rotate(rotationAngle);
          ctx.scale(1 + progress * 0.2, 1 + progress * 0.2);
          
          let displayFontSize = fontSize;
          if (isMobile) {
            displayFontSize = Math.floor(fontSize * mobileFontScaleFactor);
          }

          // Draw text with mobile-adjusted font size
          ctx.font = `${displayFontSize}px ${fontSystem.getFontFamily(fontType)}`;
          ctx.fillText(text, 0, 0);
          
          ctx.restore();
        }
        
        ctx.globalCompositeOperation = 'destination-over';
        ctx.drawImage(feedbackCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
      
        requestAnimationFrame(animate);
      }
      
      // Function to generate preset code
      function generatePresetCode(preset) {
        return JSON.stringify(preset);
      }
      
      // Function to generate embeddable code
      function generateEmbeddableCode() {
        const settings = getCurrentSettings();
        const codeObj = {
          type: "TYPO_001_PRESET",
          version: "1.0",
          preset: {
            name: presetNameInput.value.trim() || "Unnamed Preset",
            settings: settings
          }
        };
        
        // Format as JavaScript code that can be pasted directly into source
        const presetStr = JSON.stringify(codeObj.preset, null, 2);
        return `
// -------- Typography Preset Code --------
// Add this to the builtinPresets array in your source code
const customPreset = ${presetStr};
// builtinPresets.push(customPreset);
// ----------------------------------------
`;
      }
      
      // Function to create preset element
      function createPresetElement(preset, isBuiltin = false) {
        const presetItem = document.createElement('div');
        presetItem.className = 'preset-item';
        
        const presetName = document.createElement('span');
        presetName.textContent = preset.name;
        presetItem.appendChild(presetName);
        
        const presetActions = document.createElement('div');
        presetActions.className = 'preset-actions';
        
        const loadBtn = document.createElement('button');
        loadBtn.textContent = 'Load';
        loadBtn.addEventListener('click', () => {
          applySettings(preset.settings);
          showNotification(`Loaded preset: ${preset.name}`);
        });
        presetActions.appendChild(loadBtn);
        
        if (!isBuiltin) {
          const deleteBtn = document.createElement('button');
          deleteBtn.textContent = 'Delete';
          deleteBtn.addEventListener('click', () => {
            userPresets = userPresets.filter(p => p.name !== preset.name);
            localStorage.setItem('typographyPresets', JSON.stringify(userPresets));
            renderUserPresets();
            showNotification(`Deleted preset: ${preset.name}`);
          });
          presetActions.appendChild(deleteBtn);
        }
        
        const codeBtn = document.createElement('button');
        codeBtn.textContent = 'Code';
        codeBtn.addEventListener('click', () => {
          // Save the preset name for code generation
          presetNameInput.value = preset.name;
          presetCodeTextarea.value = generateEmbeddableCode();
          showNotification(`Generated code for preset: ${preset.name}`);
        });
        presetActions.appendChild(codeBtn);
        
        presetItem.appendChild(presetActions);
        return presetItem;
      }
      
      // Function to render user presets
      function renderUserPresets() {
        userPresetList.innerHTML = '';
        
        if (userPresets.length === 0) {
          const emptyMessage = document.createElement('div');
          emptyMessage.textContent = 'No saved presets yet';
          emptyMessage.style.padding = '5px';
          emptyMessage.style.opacity = '0.7';
          userPresetList.appendChild(emptyMessage);
          return;
        }
        
        userPresets.forEach(preset => {
          const presetElement = createPresetElement(preset);
          userPresetList.appendChild(presetElement);
        });
      }
      
      // Function to render builtin presets
      function renderBuiltinPresets() {
        builtinPresetList.innerHTML = '';
        
        builtinPresets.forEach(preset => {
          const presetElement = createPresetElement(preset, true);
          builtinPresetList.appendChild(presetElement);
        });
      }
      
      // Initialize preset lists
      renderUserPresets();
      renderBuiltinPresets();
      
      // Toggle preset panel
      togglePresetPanel.addEventListener('click', () => {
        presetPanel.classList.toggle('open');
      });

      feedbackEnabledControl.addEventListener('change', () => {
        feedbackEnabled = feedbackEnabledControl.checked;
        
        // Clear the feedback canvas if disabled
        if (!feedbackEnabled) {
          feedbackCtx.clearRect(0, 0, feedbackCanvas.width, feedbackCanvas.height);
        }
      });
      
      feedbackDecayControl.addEventListener('input', () => {
        feedbackDecay = parseFloat(feedbackDecayControl.value);
      });
      
      feedbackOpacityControl.addEventListener('input', () => {
        feedbackOpacity = parseFloat(feedbackOpacityControl.value);
      });
      
      feedbackZoomControl.addEventListener('input', () => {
        feedbackZoom = parseFloat(feedbackZoomControl.value);
      });
      
      feedbackShiftXControl.addEventListener('input', () => {
        feedbackShiftX = parseFloat(feedbackShiftXControl.value);
      });
      
      feedbackShiftYControl.addEventListener('input', () => {
        feedbackShiftY = parseFloat(feedbackShiftYControl.value);
      });

      // Save current settings as preset
      saveCurrentBtn.addEventListener('click', () => {
        const presetName = presetNameInput.value.trim();
        if (!presetName) {
          showNotification('Please enter a preset name');
          return;
        }
        
        // Check if name already exists
        const existingIndex = userPresets.findIndex(p => p.name === presetName);
        
        const newPreset = {
          name: presetName,
          settings: getCurrentSettings()
        };
        
        if (existingIndex >= 0) {
          // Update existing preset
          userPresets[existingIndex] = newPreset;
          showNotification(`Updated preset: ${presetName}`);
        } else {
          // Add new preset
          userPresets.push(newPreset);
          showNotification(`Saved preset: ${presetName}`);
        }
        
        localStorage.setItem('typographyPresets', JSON.stringify(userPresets));
        renderUserPresets();
        presetNameInput.value = '';
      });
      
      // Generate code for current settings
      generateCodeBtn.addEventListener('click', () => {
        const presetName = presetNameInput.value.trim() || 'Unnamed Preset';
        
        // Generate embeddable code instead of just the JSON
        presetCodeTextarea.value = generateEmbeddableCode();
        presetCodeTextarea.select();
        showNotification('Code generated! Copy to paste into source');
      });
      
      // Export preset
      exportPresetBtn.addEventListener('click', () => {
        const presetName = presetNameInput.value.trim() || 'Exported Preset';
        
        const preset = {
          name: presetName,
          settings: getCurrentSettings()
        };
        
        presetCodeTextarea.value = generatePresetCode(preset);
        presetCodeTextarea.select();
        document.execCommand('copy');
        showNotification('Preset code copied to clipboard!');
      });
      
      // Import preset
      importPresetBtn.addEventListener('click', () => {
        const code = presetCodeTextarea.value.trim();
        if (!code) {
          showNotification('Please enter preset code');
          return;
        }
        
        try {
          // Try to parse as direct JSON first
          let preset;
          
          try {
            preset = JSON.parse(code);
          } catch (e) {
            // If that fails, try to extract JSON from embedded code format
            const jsonMatch = code.match(/const\s+customPreset\s+=\s+({[\s\S]*?});/);
            if (jsonMatch && jsonMatch[1]) {
              preset = JSON.parse(jsonMatch[1]);
            } else {
              throw new Error('Could not parse preset code');
            }
          }
          
          if (!preset.name || !preset.settings) {
            throw new Error('Invalid preset format');
          }
          
          applySettings(preset.settings);
          showNotification(`Imported preset: ${preset.name}`);
          
          // Ask if user wants to save this imported preset
          if (confirm(`Do you want to save the imported preset "${preset.name}" to your collection?`)) {
            const existingIndex = userPresets.findIndex(p => p.name === preset.name);
            
            if (existingIndex >= 0) {
              // Update existing preset
              userPresets[existingIndex] = preset;
            } else {
              // Add new preset
              userPresets.push(preset);
            }
            
            localStorage.setItem('typographyPresets', JSON.stringify(userPresets));
            renderUserPresets();
          }
          
          presetCodeTextarea.value = '';
        } catch (error) {
          showNotification('Invalid preset code');
          console.error(error);
        }
      });
      
      // Save preset button in the main controls
      savePresetBtn.addEventListener('click', () => {
        presetPanel.classList.add('open');
        presetNameInput.focus();
      });
      
      // Handle control changes
      textInput.addEventListener('input', () => text = textInput.value);
      fontSizeControl.addEventListener('input', () => {
        targetFontSize = parseInt(fontSizeControl.value);
        if (!isInterpolating) fontSize = targetFontSize;
      });
      duplicationsControl.addEventListener('input', () => {
        targetDuplications = parseInt(duplicationsControl.value);
        if (!isInterpolating) duplications = targetDuplications;
      });
      blurControl.addEventListener('input', () => {
        targetBlur = parseInt(blurControl.value);
        if (!isInterpolating) blur = targetBlur;
      });
      rotationSpeedControl.addEventListener('input', () => {
        targetRotationSpeed = parseFloat(rotationSpeedControl.value);
        if (!isInterpolating) rotationSpeed = targetRotationSpeed;
      });
      distortionControl.addEventListener('input', () => {
        targetDistortion = parseInt(distortionControl.value);
        if (!isInterpolating) distortion = targetDistortion;
      });
      primaryColorControl.addEventListener('input', () => {
        targetPrimaryColor = primaryColorControl.value;
        if (!isInterpolating) primaryColor = targetPrimaryColor;
      });
      secondaryColorControl.addEventListener('input', () => {
        targetSecondaryColor = secondaryColorControl.value;
        if (!isInterpolating) secondaryColor = targetSecondaryColor;
      });
      effectTypeControl.addEventListener('change', () => {
        targetEffectType = effectTypeControl.value;
        if (!isInterpolating) effectType = targetEffectType;
      });
      fontTypeControl.addEventListener('change', () => {
        targetFontType = fontTypeControl.value;
        if (!isInterpolating) fontType = targetFontType;
      });
      transitionTimeControl.addEventListener('input', () => {
        transitionTime = parseFloat(transitionTimeControl.value);
        interpolationDuration = transitionTime * 1000;
      });
      
      // Randomize settings
      randomizeBtn.addEventListener('click', () => {
        // Save previous values
        prevFontSize = fontSize;
        prevDuplications = duplications;
        prevBlur = blur;
        prevRotationSpeed = rotationSpeed;
        prevDistortion = distortion;
        prevPrimaryColor = primaryColor;
        prevSecondaryColor = secondaryColor;
        prevEffectType = effectType;
        prevFontType = fontType;
        
        // Generate new random target values
        fontSizeControl.value = Math.floor(Math.random() * 350 + 50);
        duplicationsControl.value = Math.floor(Math.random() * 9 + 1);
        blurControl.value = Math.floor(Math.random() * 50);
        rotationSpeedControl.value = Math.floor(Math.random() * 10 + 1);
        distortionControl.value = Math.floor(Math.random() * 1000);
        
        // Random effect and font
        const effects = ['wave', 'fracture', 'spiral', 'glitch'];
        
        effectTypeControl.value = effects[Math.floor(Math.random() * effects.length)];
        
        // Set target values
        targetFontSize = parseInt(fontSizeControl.value);
        targetDuplications = parseInt(duplicationsControl.value);
        targetBlur = parseInt(blurControl.value);
        targetRotationSpeed = parseFloat(rotationSpeedControl.value);
        targetDistortion = parseInt(distortionControl.value);
        targetEffectType = effectTypeControl.value;
        
        // Start interpolation
        isInterpolating = true;
        interpolationStartTime = Date.now();
      });
      
      // Start animation
      animate();

      document.addEventListener('DOMContentLoaded', () => {
        setupMenu();
        // Check if URL has a hash and select the corresponding menu item
        checkUrlHash();
      });

      // In case the DOM is already loaded when this script runs
      if (document.readyState === 'interactive' || document.readyState === 'complete') {
        setupMenu();
        checkUrlHash();
      }

      function setupMenu() {
        const menuItems = document.querySelectorAll('.menu-item');
        
        // Menu item click handler
        menuItems.forEach(item => {
          item.addEventListener('click', (e) => {
            e.preventDefault();
            
            const clickedItem = e.target;
            const parentLi = clickedItem.parentElement;
            const section = clickedItem.getAttribute('data-section');
            
            // Toggle active state or update URL
            if (clickedItem.classList.contains('active')) {
              // If already active, deactivate and clear URL hash
              clickedItem.classList.remove('active');
              parentLi.classList.remove('active-item');
              history.pushState(null, '', window.location.pathname); // Remove hash from URL
              
              // Apply default preset when deselecting and set default text
              applyPresetByName("Unsure");
              updateCanvasText("EN5EMBLE");
            } else {
              // First, remove active class from all items
              menuItems.forEach(i => {
                i.classList.remove('active');
                i.parentElement.classList.remove('active-item');
              });
              
              // Then, add active class to clicked item
              clickedItem.classList.add('active');
              parentLi.classList.add('active-item');
              
              // Update URL without navigation - using History API
              history.pushState(null, '', `#${section}`);
              
              // Apply corresponding preset and text
              applyPresetForSection(section);
            }
            
            // Simple feedback animation
            const originalColor = window.getComputedStyle(clickedItem).color;
            clickedItem.style.color = '#ffffff';
            
            setTimeout(() => {
              clickedItem.style.color = '';
            }, 200);
            
            console.log(`Selected section: ${section}`);
          });
        });
      }
      
      // Check URL hash on page load and set the active menu item
      function checkUrlHash() {
        // First, clear all active states
        const allMenuItems = document.querySelectorAll('.menu-item');
        allMenuItems.forEach(item => {
          item.classList.remove('active');
          item.parentElement.classList.remove('active-item');
        });
        
        // Then, if there's a hash, find and activate the corresponding menu item
        if (window.location.hash) {
          const section = window.location.hash.substring(1); // Remove the # character
          const menuItem = document.querySelector(`.menu-item[data-section="${section}"]`);
          
          if (menuItem) {
            menuItem.classList.add('active');
            menuItem.parentElement.classList.add('active-item');
            
            // Apply the corresponding preset
            applyPresetForSection(section);
          }
        } else {
          // If no hash, apply the default "Unsure" preset
          applyPresetByName("Unsure");
        }
      }
      
      // Function to apply a preset based on the selected section
      function applyPresetForSection(section) {
        // Map sections to preset names and corresponding text
        const sectionMap = {
          "events": {
            preset: "Beacon of truth",
            text: "EVENTS EN5EMBLE"
          },
          "mixes": {
            preset: "Skeud",
            text: "MIXxxxxxES"
          },
          "archives": {
            preset: "Arabesque",
            text: "EN5EMBLE"
          },
          "contact": {
            preset: "Wall",
            text: "@EN5EMBLE"
          }
        };
        
        const mapping = sectionMap[section] || { preset: "Unsure", text: "EN5EMBLE" };
        
        // Apply the preset
        applyPresetByName(mapping.preset);
        
        // Update the text
        updateCanvasText(mapping.text);
      }
      
      // Function to update the canvas text
      function updateCanvasText(newText) {
        const textInput = document.getElementById('text-content');
        if (textInput) {
          textInput.value = newText;
          // Trigger the input event to update the canvas
          const event = new Event('input', { bubbles: true });
          textInput.dispatchEvent(event);
        }
      }
      
      // Function to find and apply a preset by name
      function applyPresetByName(presetName) {
        // First check built-in presets
        let preset = builtinPresets.find(p => p.name === presetName);
        
        // If not found in built-in presets, check user presets
        if (!preset && userPresets) {
          preset = userPresets.find(p => p.name === presetName);
        }
        
        // If preset found, apply it
        if (preset) {
          console.log(`Applying preset: ${presetName}`);
          applySettings(preset.settings);
        } else {
          console.warn(`Preset not found: ${presetName}`);
        }
      }
      
      // Listen for back/forward browser navigation
      window.addEventListener('popstate', checkUrlHash);
      
      // Also listen for hash changes directly (for manual URL edits)
      window.addEventListener('hashchange', checkUrlHash);
    });
  </script>
</body>
</html>