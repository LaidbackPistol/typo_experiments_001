<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TYPO_001 Experiment</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Alfa+Slab+One&family=Bebas+Neue&family=Cinzel:wght@700&family=Comfortaa:wght@700&family=DM+Serif+Display&family=Faster+One&family=Permanent+Marker&family=Righteous&family=Rubik+Glitch&family=Russo+One&family=Special+Elite&family=VT323&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Doto:wght,ROND@200,4&family=Offside&family=Rubik+Puddles&family=Silkscreen&family=Tulpen+One&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: monospace;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      height: 100vh;
      width: 100vw;
      cursor: crosshair;
    }

    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #feedback-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1; /* Behind the main canvas */
    }

    #typography-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* New styles for the feedback canvas */
    #feedback-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1; /* Behind the main canvas */
    }

    /* Add feedback effect controls to existing controls */
    .control-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 8px;
      backdrop-filter: blur(5px);
      z-index: 100;
      opacity: 0.3;
      transition: all 0.3s ease;
      transform: translateX(0);
    }

    .controls:hover {
      opacity: 1;
    }

    .controls.hidden {
      transform: translateX(calc(100% + 20px));
    }

    .toggle-controls-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 101;
      border: 1px solid #444;
      font-weight: bold;
      font-size: 18px;
      opacity: 0.5;
      transition: opacity 0.3s ease;
    }

    .toggle-controls-panel:hover {
      background: rgba(50, 50, 50, 0.7);
      opacity: 1;
    }

    .toggle-controls-panel.panel-hidden {
      right: 20px;
    }

    .control-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .control-label {
      font-size: 12px;
      width: 120px;
    }

    input[type="range"] {
      width: 120px;
      background: transparent;
    }

    input[type="color"] {
      width: 30px;
      height: 30px;
      border: none;
      background: none;
      cursor: pointer;
    }

    select, button {
      background: rgba(30, 30, 30, 0.8);
      color: #fff;
      border: 1px solid #555;
      padding: 5px;
      border-radius: 4px;
      cursor: pointer;
    }

    button {
      width: 100%;
      margin-top: 5px;
      transition: background 0.3s ease;
    }

    button:hover {
      background: rgba(60, 60, 60, 0.8);
    }

    .text-input {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
      padding: 10px;
      border-radius: 8px;
      z-index: 100;
      opacity: 0.3;
      transition: opacity 0.3s ease;
    }

    .text-input:hover {
      opacity: 1;
    }

    #text-content {
      background: rgba(30, 30, 30, 0.8);
      color: #fff;
      border: 1px solid #555;
      padding: 5px;
      border-radius: 4px;
      width: 200px;
    }

    /* Preset System Styles */
    .preset-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(5px);
      padding: 15px;
      border-radius: 8px;
      z-index: 100;
      width: 300px;
      max-height: 80vh;
      overflow-y: auto;
      transform: translateX(320px);
      transition: transform 0.3s ease;
    }

    .preset-panel.open {
      transform: translateX(0);
    }

    .preset-panel h3 {
      margin-bottom: 10px;
      font-size: 16px;
    }

    .preset-list {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin-bottom: 15px;
      max-height: 200px;
      overflow-y: auto;
    }

    .preset-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px;
      border: 1px solid #333;
      border-radius: 4px;
    }

    .preset-item:hover {
      background: rgba(60, 60, 60, 0.5);
    }

    .preset-actions {
      display: flex;
      gap: 5px;
    }

    .preset-actions button {
      width: auto;
      padding: 2px 5px;
      margin: 0;
      font-size: 11px;
    }

    #preset-name {
      width: 100%;
      margin-bottom: 10px;
      background: rgba(30, 30, 30, 0.8);
      color: #fff;
      border: 1px solid #555;
      padding: 5px;
      border-radius: 4px;
    }

    #preset-code {
      width: 100%;
      height: 100px;
      margin-top: 10px;
      background: rgba(30, 30, 30, 0.8);
      color: #fff;
      border: 1px solid #555;
      padding: 5px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 11px;
      resize: vertical;
    }

    .preset-buttons {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .preset-buttons button {
      flex: 1;
    }

    .toggle-preset-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 101;
      border: 1px solid #444;
      font-weight: bold;
      font-size: 18px;
    }

    .toggle-preset-panel:hover {
      background: rgba(50, 50, 50, 0.7);
    }

    .notification {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 4px;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .notification.show {
      opacity: 1;
    }

    /* Built-in presets section */
    .preset-category {
      margin-bottom: 15px;
    }

    .preset-category h4 {
      margin-bottom: 5px;
      font-size: 14px;
      color: #aaa;
      border-bottom: 1px solid #333;
      padding-bottom: 3px;
    }

    .font-heading {
      margin-top: 10px;
      margin-bottom: 2px;
      font-size: 12px;
      color: #aaa;
      opacity: 0.8;
    }

    .font-preview {
      display: inline-block;
      margin-left: 10px;
      font-size: 14px;
      opacity: 0.8;
    }

    .menu-container {
      position: fixed;
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 100;
    }

    .main-menu ul {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 20px;
      transition: all 0.4s ease;
    }

    .main-menu li {
      position: relative;
      transition: all 0.4s ease;
    }

    .menu-item {
      color: #ffff00; /* Yellow text color */
      font-size: 22px; /* Increased from 18px */
      text-decoration: none;
      transition: all 0.4s ease;
      font-family: monospace;
      opacity: 0.9;
      display: inline-block;
    }

    /* Increase size for active menu items on desktop */
    .menu-item.active {
      font-size: 28px; /* Increased from 24px */
      font-weight: bold;
      opacity: 1;
      transform: translateX(5px);
    }

    .menu-item:hover {
      opacity: 0.6;
      cursor: pointer;
    }
    
    /* Push items away from active item */
    li.active-item ~ li {
      transform: translateY(8px);
    }
    
    li:not(.active-item) + li.active-item ~ li {
      transform: translateY(8px);
    }
    
    /* Media query for responsive design */
    @media (max-width: 768px) {
      /* Keep all menu items on the same baseline */
      .menu-container {
        top: auto;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
      }

      .main-menu ul {
        flex-direction: row;
        justify-content: center;
        gap: 15px;
        align-items: baseline; /* Important: align items by their baseline */
      }

      .menu-item {
        font-size: 18px;
        transform: translateY(0); /* Remove vertical shift */
        position: relative; /* For z-index control */
        display: inline-block;
        line-height: 1.2; /* Consistent line height */
        vertical-align: baseline; /* Keep text aligned at baseline */
      }
      
      .menu-item.active {
        font-size: 24px;
        transform: translateX(0); /* No position change, just size */
        z-index: 5; /* Keep active item on top */
      }
      
      /* Change how siblings are moved to avoid vertical shift */
      li.active-item ~ li {
        transform: translateX(8px);
        transform-origin: left center; /* Keep transform centered vertically */
      }
      
      li:not(.active-item) + li.active-item ~ li {
        transform: translateX(8px);
        transform-origin: left center; /* Keep transform centered vertically */
      }
      
      /* Add margin adjustment to compensate for font size change */
      li.active-item {
        margin-bottom: 0; /* Prevent margin from affecting layout */
      }
    }

    .archive-gallery {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: transparent;
      z-index: 200;
      overflow-y: auto;
      display: none;
      padding: 60px 20px 20px 20px;
      pointer-events: none; /* Make the entire gallery click-through by default */
    }

    .archive-gallery.active {
      display: block;
    }

    /* Gallery container */
    .gallery-container {
      max-width: 1200px;
      margin: 0 auto;
      background-color: transparent;
    }

    /* Album styling - restore pointer events */
    .album {
      margin-bottom: 80px;
      background-color: transparent;
      pointer-events: auto; /* Re-enable pointer events for album elements */
    }

    /* Album title */
    .album-title {
      color: #ffff00;
      font-size: 18px;
      margin-bottom: 4px;
      font-family: monospace;
      text-shadow: 0 0 10px rgba(0, 0, 0, 0.8), 0 0 20px rgba(0, 0, 0, 0.8);
      pointer-events: auto; /* Ensure title is clickable */
    }

    /* Album images grid */
    .album-images {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(450px, 1fr));
      gap: 4px;
      background-color: transparent;
      pointer-events: auto; /* Ensure images are clickable */
    }

    /* Individual image containers */
    .album-image {
      width: 100%;
      height: 0;
      padding-bottom: 75%;
      position: relative;
      overflow: hidden;
      background-color: transparent;
      pointer-events: auto; /* Ensure image containers are clickable */
    }

    .album-image img {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.3s ease;
      border: 1px solid rgba(255, 255, 255, 0.2); /* Subtle border to define image boundaries */
    }

    .album-image:hover img {
      transform: scale(1.05);
    }

    .gallery-close:hover {
      background: rgba(50, 50, 50, 0.7);
    }

    /* Fullscreen Viewer Styles */
    .fullscreen-viewer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.95);
      z-index: 300;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .fullscreen-viewer.active {
      display: flex;
    }

    .viewer-controls {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: space-between;
      padding: 20px;
      box-sizing: border-box;
      z-index: 301;
    }

    .viewer-controls button {
      background: rgba(0, 0, 0, 0.5);
      color: white;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.3s ease;
    }

    .viewer-controls button:hover {
      background: rgba(50, 50, 50, 0.7);
    }

    .close-button {
      position: fixed;
      top: 20px;
      right: 20px;
    }

    .prev-button, .next-button {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
    }

    .prev-button {
      left: 20px;
    }

    .next-button {
      right: 20px;
    }

    .viewer-image-container {
      width: 90%;
      height: 90%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .viewer-image {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      transition: opacity 0.3s ease;
    }

    .image-caption {
      position: absolute;
      bottom: 20px;
      left: 0;
      width: 100%;
      text-align: center;
      color: white;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      font-family: monospace;
    }

    .mix-title {
      color: #ffff00; /* Same yellow as your menu items */
      font-family: monospace; /* To match your menu style */
    }

  /* Mobile Responsive Styles */
  @media (max-width: 768px) {
      .album-images {
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        gap: 0px;
      }
      
      .album-title {
        font-size: 24px;
      }
      
      .archive-gallery {
        padding: 60px 10px 70px 10px; /* Add bigger bottom padding (70px) to make room for menu */
        height: calc(100% - 64px); /* Reduce height to leave space for menu */
        bottom: 64px; /* Position above the menu bar */
        max-height: calc(100% - 64px); /* Set max height to ensure visibility of menu */
      }
      
      /* Add mobile fixes for mixes gallery to match archives */
      .mixes-gallery {
        padding: 60px 10px 70px 10px; /* Add bigger bottom padding (70px) to make room for menu */
        height: calc(100% - 64px); /* Reduce height to leave space for menu */
        bottom: 64px; /* Position above the menu bar */
        max-height: calc(100% - 64px); /* Set max height to ensure visibility of menu */
        box-sizing: border-box; /* Ensure padding is included in height calculation */
      }
      
      /* Improve padding and spacing for mix containers on mobile */
      .mix-container {
        margin-bottom: 40px; /* Increase space between mixes */
        padding-bottom: 10px; /* Add some padding at bottom */
      }
      
      /* Ensure the last mix doesn't get cut off */
      .mix-container:last-child {
        margin-bottom: 80px; /* Extra space at the end of the list */
      }
      
      /* Ensure Soundcloud embeds are fully visible */
      .soundcloud-embed {
        margin-bottom: 15px;
      }
    }

    .mixes-gallery {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: transparent;
      z-index: 200;
      overflow-y: auto;
      display: none;
      padding: 60px 20px 20px 20px;
      pointer-events: none; /* This makes it click-through by default */
    }

    .mixes-gallery.active {
      display: block;
    }

    /* Mix container - base styles for all screen sizes */
    .mix-container {
      margin-bottom: 30px;
      padding: 0;
      pointer-events: auto;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
      background-color: transparent;
      border: none;
      opacity: 1;
    }

    .soundcloud-embed {
      width: 100%;
      margin-bottom: 10px;
      background-color: transparent;
      padding: 0;
      border-radius: 0;
    }

    /* Desktop-only layout (screens larger than 768px) */
    @media (min-width: 769px) {
      /* Menu overlap prevention - only add padding on left side */
      .mixes-gallery {
        padding-left: 200px; /* Make space for the menu */
        padding-right: 20px; /* Default right padding */
        box-sizing: border-box;
        perspective: 1000px; /* For parallax effect */
      }
      
      /* Adjust the gallery container to use full available width */
      .mixes-gallery .gallery-container {
        display: grid;
        grid-template-columns: repeat(12, 1fr);
        grid-auto-rows: minmax(100px, auto);
        gap: 20px;
        padding: 20px;
        max-width: 100%; /* Use full width */
        margin-left: 0;
      }
      
      /* Mix container desktop styles */
      .mix-container {
        grid-column: span 12;
        max-width: none;
        margin: 0;
        position: relative;
        transform-origin: center;
        transition: transform 0.3s ease-out, opacity 0.3s ease;
        width: 100%;
        box-sizing: border-box;
      }
      
      /* Expanded column spans to utilize more space */
      .mix-container:nth-child(4n+1) {
        grid-column: 1 / span 10;
        transform: rotate(-1deg);
      }
      
      .mix-container:nth-child(4n+2) {
        grid-column: 2 / span 10;
        transform: rotate(1deg);
      }
      
      .mix-container:nth-child(4n+3) {
        grid-column: 1 / span 10;
        transform: rotate(0.5deg);
      }
      
      .mix-container:nth-child(4n+4) {
        grid-column: 2 / span 10;
        transform: rotate(-0.5deg);
      }
      
      /* Hover effects */
      .mix-container:hover {
        transform: scale(1.02) rotate(0);
        z-index: 10;
      }
      
      /* Make soundcloud embeds more visually interesting */
      .soundcloud-embed {
        filter: drop-shadow(0 5px 15px rgba(0, 0, 0, 0.3));
        transition: all 0.3s ease;
        transform-origin: center;
      }
      
      .soundcloud-embed iframe {
        max-width: 100%;
      }
      
      .mix-container:hover .soundcloud-embed {
        filter: drop-shadow(0 8px 25px rgba(0, 0, 0, 0.4));
      }
      
      /* Enhance mix titles */
      .mix-title {
        transform: translateY(0);
        transition: transform 0.2s ease;
        text-shadow: 0 0 15px rgba(0, 0, 0, 0.6);
        color: #ffff00; /* Same yellow as your menu items */
        font-family: monospace; /* To match your menu style */
      }
      
      .mix-container:hover .mix-title {
        transform: translateY(-5px);
      }
    }

    /* Animation for staggered appearance */
    @keyframes fadeSlideIn {
      from {
        opacity: 0;
        transform: translateY(20px) rotate(0deg);
      }
      to {
        opacity: 1;
        transform: translateY(0) rotate(var(--rotation));
      }
    }
    
    /* Increase menu typography size on PC only */
    .menu-item {
      color: #ffff00; /* Yellow text color */
      font-size: 22px; /* Increased from 18px */
      text-decoration: none;
      transition: all 0.4s ease;
      font-family: monospace;
      opacity: 0.9;
      display: inline-block;
    }

    .menu-item.active {
      font-size: 28px; /* Increased from 24px */
      font-weight: bold;
      opacity: 1;
      transform: translateX(5px);
    }

    /* Keep original sizes on mobile */
    @media (max-width: 768px) {
      .menu-item {
        font-size: 18px; /* Original size for mobile */
      }
      
      .menu-item.active {
        font-size: 24px; /* Original size for mobile */
      }
    }
  </style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="feedback-canvas"></canvas>
    <canvas id="typography-canvas"></canvas>
  </div>
  <!-- Archive gallery -->
  <div id="archive-gallery" class="archive-gallery">
    <div class="gallery-container">
      <!-- Albums will be loaded here dynamically -->
    </div>
  </div>
  <!-- Mixes gallery -->
  <div id="mixes-gallery" class="mixes-gallery">
    <div class="gallery-container">
      <!-- Mixes will be loaded here dynamically -->
    </div>
  </div>
  <!-- Fullscreen Image Viewer -->
  <div id="fullscreen-viewer" class="fullscreen-viewer">
    <div class="viewer-controls">
      <button class="prev-button">&lt;</button>
      <button class="next-button">&gt;</button>
      <button class="close-button">×</button>
    </div>
    <div class="viewer-image-container">
      <img class="viewer-image" src="" alt="">
    </div>
  </div>
  <div class="text-input">
    <input type="text" id="text-content" placeholder="Type something..." value="EN5EMBLE">
  </div>
  <div class="menu-container">
    <nav class="main-menu">
      <ul>
        <li><a href="#events" class="menu-item" data-section="events">events</a></li>
        <li><a href="#mixxs" class="menu-item" data-section="mixxs">mixxs</a></li>
        <li><a href="#archives" class="menu-item" data-section="archives">archives</a></li>
        <li><a href="#contact" class="menu-item" data-section="contact">contact</a></li>
      </ul>
    </nav>
  </div>
  <div class="toggle-controls-panel">C</div>
  <div class="controls">
    <div class="control-group">
      <span class="control-label">Font Size</span>
      <input type="range" id="font-size" min="50" max="400" value="138">
    </div>
    <div class="control-group">
      <span class="control-label">Duplications</span>
      <input type="range" id="duplications" min="1" max="20" value="20">
    </div>
    <div class="control-group">
      <span class="control-label">Blur Intensity</span>
      <input type="range" id="blur" min="0" max="50" value="50">
    </div>
    <div class="control-group">
      <span class="control-label">Rotation Speed</span>
      <input type="range" id="rotation-speed" min="0" max="10" value="0">
    </div>
    <div class="control-group">
      <span class="control-label">Distortion</span>
      <input type="range" id="distortion" min="0" max="1000" value="1000">
    </div>
    <div class="control-group">
      <span class="control-label">Primary Color</span>
      <input type="color" id="primary-color" value="#ffffff">
    </div>
    <div class="control-group">
      <span class="control-label">Secondary Color</span>
      <input type="color" id="secondary-color" value="#ffffff">
    </div>
    <div class="control-group">
      <span class="control-label">Effect Type</span>
      <select id="effect-type">
        <option value="glitch">Glitch</option>
        <option value="wave">Wave</option>
        <option value="fracture">Fracture</option>
        <option value="spiral">Spiral</option>
      </select>
    </div>
    <div class="control-group">
      <span class="control-label">Font Type</span>
      <select id="font-type">
        <option value="sans-serif">Sans-serif</option>
        <option value="serif">Serif</option>
        <option value="monospace">Monospace</option>
      </select>
    </div>
    <div class="control-group">
      <span class="control-label">Trail Effect</span>
      <input type="checkbox" id="feedback-enabled" checked>
    </div>
    <div class="control-group">
      <span class="control-label">Trail Decay</span>
      <input type="range" id="feedback-decay" min="0.1" max="0.9" step="0.01" value="0.5">
    </div>
    <div class="control-group">
      <span class="control-label">Trail Opacity</span>
      <input type="range" id="feedback-opacity" min="0.05" max="0.6" step="0.01" value="0.1">
    </div>
    <div class="control-group">
      <span class="control-label">Trail Zoom</span>
      <input type="range" id="feedback-zoom" min="0.8" max="1.2" step="0.001" value="0.95">
    </div>
    <div class="control-group">
      <span class="control-label">Trail Shift X</span>
      <input type="range" id="feedback-shift-x" min="-50" max="50" step="0.5" value="0">
    </div>
    <div class="control-group">
      <span class="control-label">Trail Shift Y</span>
      <input type="range" id="feedback-shift-y" min="-50" max="50" step="0.5" value="0">
    </div>
    <!-- Transition time control -->
    <div class="control-group">
      <span class="control-label">Transition Time</span>
      <input type="range" id="transition-time" min="0.01" max="0.5" step="0.01" value="0.1">
    </div>
    <button id="randomize">Randomize</button>
    <button id="save-preset-btn">Save Preset</button>
  </div>

  <!-- Preset Toggle Button -->
  <div class="toggle-preset-panel">P</div>

  <!-- Preset Panel -->
  <div class="preset-panel">
    <h3>TYPO_001 Presets</h3>
    
    <!-- Built-in Presets -->
    <div class="preset-category">
      <h4>Built-in Presets</h4>
      <div class="preset-list" id="builtin-preset-list">
        <!-- Built-in presets will be loaded here -->
      </div>
    </div>
    
    <!-- User Presets -->
    <div class="preset-category">
      <h4>Your Presets</h4>
      <div class="preset-list" id="user-preset-list">
        <!-- User presets will be loaded here -->
      </div>
    </div>
    
    <!-- Save New Preset Form -->
    <h4>Create New Preset</h4>
    <input type="text" id="preset-name" placeholder="Preset Name">
    <div class="preset-buttons">
      <button id="save-current">Save Current</button>
      <button id="generate-code">Generate Code</button>
    </div>
    
    <!-- Import/Export -->
    <h4>Import/Export</h4>
    <textarea id="preset-code" placeholder="Paste preset code here to import"></textarea>
    <div class="preset-buttons">
      <button id="import-preset">Import</button>
      <button id="export-preset">Export Current</button>
    </div>
  </div>

  <!-- Notification -->
  <div class="notification" id="notification"></div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Elements
      const canvas = document.getElementById('typography-canvas');
      const ctx = canvas.getContext('2d');
      const feedbackCanvas = document.getElementById('feedback-canvas');
      const feedbackCtx = feedbackCanvas.getContext('2d');
      
      const textInput = document.getElementById('text-content');
      
      // Controls
      const fontSizeControl = document.getElementById('font-size') || { value: 138, addEventListener: () => {} };
      const duplicationsControl = document.getElementById('duplications') || { value: 20, addEventListener: () => {} };
      const blurControl = document.getElementById('blur') || { value: 50, addEventListener: () => {} };
      const rotationSpeedControl = document.getElementById('rotation-speed') || { value: 0, addEventListener: () => {} };
      const distortionControl = document.getElementById('distortion') || { value: 1000, addEventListener: () => {} };
      const primaryColorControl = document.getElementById('primary-color') || { value: "#ffffff", addEventListener: () => {} };
      const secondaryColorControl = document.getElementById('secondary-color') || { value: "#ffffff", addEventListener: () => {} };
      const effectTypeControl = document.getElementById('effect-type') || { value: "glitch", addEventListener: () => {} };
      const fontTypeControl = document.getElementById('font-type') || { value: "sans-serif", addEventListener: () => {} };
      const transitionTimeControl = document.getElementById('transition-time') || { value: 0.1, addEventListener: () => {} };
      const randomizeBtn = document.getElementById('randomize');

      // feedback effect controls
      const feedbackEnabledControl = document.getElementById('feedback-enabled');
      const feedbackDecayControl = document.getElementById('feedback-decay');
      const feedbackOpacityControl = document.getElementById('feedback-opacity');
      const feedbackZoomControl = document.getElementById('feedback-zoom');
      const feedbackShiftXControl = document.getElementById('feedback-shift-x');
      const feedbackShiftYControl = document.getElementById('feedback-shift-y');
      
      // Preset Controls
      const togglePresetPanel = document.querySelector('.toggle-preset-panel');
      const presetPanel = document.querySelector('.preset-panel');
      const userPresetList = document.getElementById('user-preset-list');
      const builtinPresetList = document.getElementById('builtin-preset-list');
      const presetNameInput = document.getElementById('preset-name');
      const saveCurrentBtn = document.getElementById('save-current');
      const generateCodeBtn = document.getElementById('generate-code');
      const importPresetBtn = document.getElementById('import-preset');
      const exportPresetBtn = document.getElementById('export-preset');
      const presetCodeTextarea = document.getElementById('preset-code');
      const savePresetBtn = document.getElementById('save-preset-btn');
      const notification = document.getElementById('notification');

      // Archive Gallery Variables
      const archiveMenuItem = document.querySelector('.menu-item[data-section="archives"]');
      const archiveGallery = document.getElementById('archive-gallery');
      const galleryContainer = archiveGallery.querySelector('.gallery-container');
      const closeButton = archiveGallery.querySelector('.gallery-close');

      // Fullscreen Viewer Variables
      const fullscreenViewer = document.getElementById('fullscreen-viewer');
      const prevButton = fullscreenViewer.querySelector('.prev-button');
      const nextButton = fullscreenViewer.querySelector('.next-button');
      const closeViewerButton = fullscreenViewer.querySelector('.close-button');
      const viewerImage = fullscreenViewer.querySelector('.viewer-image');
      let currentImageIndex = 0;
      let currentGalleryImages = [];

      // Variables for the mixes gallery
      const mixxsMenuItem = document.querySelector('.menu-item[data-section="mixxs"]');
      const mixesGallery = document.getElementById('mixes-gallery');
      const mixesContainer = mixesGallery.querySelector('.gallery-container');
      
      const mobileFontScaleFactor = 0.5;

      // THEN define the validateControls function after all the controls are defined
      function validateControls() {
        const requiredControls = [
          { id: 'font-size', element: fontSizeControl },
          { id: 'duplications', element: duplicationsControl },
          { id: 'blur', element: blurControl },
          { id: 'rotation-speed', element: rotationSpeedControl },
          { id: 'distortion', element: distortionControl },
          { id: 'primary-color', element: primaryColorControl },
          { id: 'secondary-color', element: secondaryColorControl },
          { id: 'effect-type', element: effectTypeControl },
          { id: 'font-type', element: fontTypeControl }
        ];
        
        const missingControls = requiredControls.filter(control => !control.element);
        if (missingControls.length > 0) {
          missingControls.forEach(control => {
            console.error(`Missing required control element: #${control.id}`);
          });
          console.warn(`Found ${missingControls.length} missing controls. App may not function correctly.`);
        }
        
        return missingControls.length === 0;
      }

      // NOW call validateControls after it's defined and after the controls are defined
      const controlsValid = validateControls();

      // State - with fallbacks for each value
      let text = textInput ? textInput.value : 'EN5EMBLE';
      let fontSize = fontSizeControl && fontSizeControl.value ? parseInt(fontSizeControl.value) : 138;
      let duplications = duplicationsControl && duplicationsControl.value ? parseInt(duplicationsControl.value) : 20;
      let blur = blurControl && blurControl.value ? parseInt(blurControl.value) : 50;
      let rotationSpeed = rotationSpeedControl && rotationSpeedControl.value ? parseFloat(rotationSpeedControl.value) : 0;
      let distortion = distortionControl && distortionControl.value ? parseInt(distortionControl.value) : 1000;
      let primaryColor = primaryColorControl && primaryColorControl.value ? primaryColorControl.value : '#ffffff';
      let secondaryColor = secondaryColorControl && secondaryColorControl.value ? secondaryColorControl.value : '#ffffff';
      let effectType = effectTypeControl && effectTypeControl.value ? effectTypeControl.value : 'glitch';
      let fontType = fontTypeControl && fontTypeControl.value ? fontTypeControl.value : 'sans-serif';
      let feedbackEnabled = feedbackEnabledControl && feedbackEnabledControl.checked;
      let feedbackDecay = feedbackDecayControl ? parseFloat(feedbackDecayControl.value) : 0.5;
      let feedbackOpacity = feedbackOpacityControl ? parseFloat(feedbackOpacityControl.value) : 0.1;
      let feedbackZoom = feedbackZoomControl ? parseFloat(feedbackZoomControl.value) : 0.95;
      let feedbackShiftX = feedbackShiftXControl ? parseFloat(feedbackShiftXControl.value) : 0;
      let feedbackShiftY = feedbackShiftYControl ? parseFloat(feedbackShiftYControl.value) : 0;
      let transitionTime = transitionTimeControl && transitionTimeControl.value ? parseFloat(transitionTimeControl.value) : 0.1;
      
      // Target values for interpolation
      let targetFontSize = fontSize;
      let targetDuplications = duplications;
      let targetBlur = blur;
      let targetRotationSpeed = rotationSpeed;
      let targetDistortion = distortion;
      let targetPrimaryColor = primaryColor;
      let targetSecondaryColor = secondaryColor;
      let targetEffectType = effectType;
      let targetFontType = fontType;
      
      // Interpolation state
      let isInterpolating = false;
      let interpolationStartTime = 0;
      let interpolationDuration = transitionTime * 1000; // in milliseconds
      
      // Previous values for interpolation
      let prevFontSize = fontSize;
      let prevDuplications = duplications;
      let prevBlur = blur;
      let prevRotationSpeed = rotationSpeed;
      let prevDistortion = distortion;
      let prevPrimaryColor = primaryColor;
      let prevSecondaryColor = secondaryColor;
      let prevEffectType = effectType;
      let prevFontType = fontType;
      
      // Mouse position for interactive effects
      let mouseX = 0;
      let mouseY = 0;
      
      // Animation variables
      let time = 0;
      let isAnimating = true;
      
      // User presets storage
      let userPresets = JSON.parse(localStorage.getItem('typographyPresets')) || [];

      // Variables for feedback processing
      let frameCount = 0;

      const fontSystem = {
        // Maps display names to actual CSS font families
        fontMap: {
          // Standard fonts (maintaining backward compatibility)
          "sans-serif": "sans-serif",
          "serif": "serif", 
          "monospace": "monospace",

          // Display fonts
          "Alfa Slab": "'Alfa Slab One', sans-serif",
          "Cinzel": "'Cinzel', serif",

          //Creative fonts
          "Silkscreen": "'Silkscreen', sans-serif",
          "Offside": "'Offside', sans-serif",
          "Tulpen One": "'Tulpen One', sans-serif",
          "Doto": "'Doto', sans-serif"
        },
        
        // Categories for organization
        categories: {
          "Standard": ["sans-serif", "serif", "monospace"],
          "Display": ["Alfa Slab", "Cinzel"],
          "Creative": ["Silkscreen", "Offside", "Tulpen One", "Doto"]
        },
        
        // Get actual font family from selection name
        getFontFamily(fontName) {
          return this.fontMap[fontName] || fontName;
        },
        
        // Ensure backward compatibility with old presets
        getCompatibleFontName(fontFamily) {
          // If it's a direct match, return it
          if (this.fontMap[fontFamily]) {
            return fontFamily;
          }
          
          // Look for the font family in the values
          for (const [key, value] of Object.entries(this.fontMap)) {
            if (value === fontFamily) {
              return key;
            }
          }
          
          // Default fallback
          return "sans-serif";
        },
        
        // Preload fonts to prevent FOUC (Flash of Unstyled Content)
        preloadFonts() {
          const preloadDiv = document.createElement('div');
          preloadDiv.style.opacity = '0';
          preloadDiv.style.position = 'absolute';
          preloadDiv.style.top = '-9999px';
          
          // Create a span for each font
          for (const fontFamily of Object.values(this.fontMap)) {
            const span = document.createElement('span');
            span.style.fontFamily = fontFamily;
            span.textContent = 'abcdefghijklmnopqrstuvwxyz0123456789';
            preloadDiv.appendChild(span);
          }
          
          document.body.appendChild(preloadDiv);
          
          // Remove after a delay to ensure fonts are loaded
          setTimeout(() => {
            document.body.removeChild(preloadDiv);
          }, 3000);
        }
      };

      // Replace your populateFontSelector function with this fixed version:
      function populateFontSelector() {
        const fontTypeSelect = document.getElementById('font-type');
        if (!fontTypeSelect) {
          console.error('Font type select element not found!');
          return;
        }
        
        fontTypeSelect.innerHTML = ''; // Clear existing options
        
        // Add each category and its fonts
        for (const [category, fonts] of Object.entries(fontSystem.categories)) {
          // Add category group
          const groupElement = document.createElement('optgroup');
          groupElement.label = category;
          
          // Add fonts in this category
          fonts.forEach(fontName => {
            const option = document.createElement('option');
            option.value = fontName;
            option.textContent = fontName;
            option.style.fontFamily = fontSystem.getFontFamily(fontName);
            
            // Set default selection for the first standard font (sans-serif)
            if (fontName === 'sans-serif') {
              option.selected = true;
            }
            
            groupElement.appendChild(option);
          });
          
          fontTypeSelect.appendChild(groupElement);
        }
        
        // Update the select styling to show the actual font
        fontTypeSelect.addEventListener('change', function() {
          if (this.value) {
            this.style.fontFamily = fontSystem.getFontFamily(this.value);
          }
        });
        
        // Set initial style with safety check
        try {
          if (fontTypeSelect.options.length > 0) {
            // Ensure a value exists by forcing selection of first option if none selected
            if (!fontTypeSelect.value) {
              fontTypeSelect.selectedIndex = 0;
            }
            fontTypeSelect.style.fontFamily = fontSystem.getFontFamily(fontTypeSelect.value);
          } else {
            // Fallback if somehow we have no options
            fontTypeSelect.style.fontFamily = 'sans-serif';
          }
        } catch (e) {
          console.error('Error setting initial font style:', e);
          // Fallback to a safe default
          fontTypeSelect.style.fontFamily = 'sans-serif';
        }
      }

      // Make it available globally if needed
      window.fontSystem = fontSystem;
      
      // Only then initialize the font selector
      populateFontSelector();
      
      // And finally, preload fonts
      fontSystem.preloadFonts();

      let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      let hasGyro = false;
      let gyroData = { beta: 0, gamma: 0 };

      // Built-in presets
      const builtinPresets = [
        {
          name: "Unsure",
          settings: {
            fontSize: 138,
            duplications: 20,
            blur: 50,
            rotationSpeed: 0,
            distortion: 1000,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "glitch",
            fontType: "sans-serif",
            feedbackEnabled: false,
            feedbackDecay: 0.6,
            feedbackOpacity: 0.1,
            feedbackZoom: 0.98,
            feedbackShiftX: 0,
            feedbackShiftY: 0
          }
        },
        {
          name: "Beacon of truth",
          settings: {
            fontSize: 50,
            duplications: 20,
            blur: 0,
            rotationSpeed: 3,
            distortion: 330,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "wave",
            fontType: "monospace",
            feedbackEnabled: true,
            feedbackDecay: 0.9,
            feedbackOpacity: 0.41,
            feedbackZoom: 0.93,
            feedbackShiftX: 0,
            feedbackShiftY: 0
          }
        },
        {
            name: "Skeud",
            settings: {
            fontSize: 150,
            duplications: 9,
            blur: 0,
            rotationSpeed: 5,
            distortion: 0,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "spiral",
            fontType: "serif",
            feedbackDecay: 0.75,
            feedbackOpacity: 0.15,
            feedbackZoom: 1.2,
            feedbackShiftX: 0,
            feedbackShiftY: 0
        }
        },
        {
            name: "Arabesque",
            settings: {
            fontSize: 400,
            duplications: 9,
            blur: 2,
            rotationSpeed: 9,
            distortion: 0,
            primaryColor: "#ffffff",
            secondaryColor: "#000000",
            effectType: "spiral",
            fontType: "serif",
            feedbackEnabled: false,
            feedbackDecay: 0.6,
            feedbackOpacity: 0.1,
            feedbackZoom: 0.98,
            feedbackShiftX: 0,
            feedbackShiftY: 0
        }
        },
        {
            name: "Equilibrium",
            settings: {
            fontSize: 68,
            duplications: 11,
            blur: 0,
            rotationSpeed: 0,
            distortion: 199,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "spiral",
            fontType: "monospace",
            feedbackEnabled: true,
            feedbackDecay: 0.17,
            feedbackOpacity: 0.13,
            feedbackZoom: 1.2,
            feedbackShiftX: -4,
            feedbackShiftY: -16.5
        }
        },
        {
            name: "Archives",
            settings: {
            fontSize: 125,
            duplications: 19,
            blur: 17,
            rotationSpeed: 0,
            distortion: 922,
            primaryColor: "#404040",
            secondaryColor: "#000000",
            effectType: "spiral",
            fontType: "monospace",
            feedbackEnabled: true,
            feedbackDecay: 0.77,
            feedbackOpacity: 0.54,
            feedbackZoom: 0.985,
            feedbackShiftX: 0,
            feedbackShiftY: 0
        }
        },
        {
            name: "001",
            settings: {
            fontSize: 63,
            duplications: 7,
            blur: 0,
            rotationSpeed: 1,
            distortion: 234,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "wave",
            fontType: "monospace",
            feedbackEnabled: true,
            feedbackDecay: 0.42,
            feedbackOpacity: 0.41,
            feedbackZoom: 0.93,
            feedbackShiftX: 0,
            feedbackShiftY: 0
        }
        },
        {
            name: "002",
            settings: {
            fontSize: 192,
            duplications: 8,
            blur: 2,
            rotationSpeed: 1,
            distortion: 850,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "glitch",
            fontType: "sans-serif",
            feedbackEnabled: false,
            feedbackDecay: 0.6,
            feedbackOpacity: 0.1,
            feedbackZoom: 0.98,
            feedbackShiftX: 0,
            feedbackShiftY: 0
        }
        },
        {
            name: "003",
            settings: {
            fontSize: 100,
            duplications: 20,
            blur: 0,
            rotationSpeed: 8,
            distortion: 0,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "spiral",
            fontType: "Doto",
            feedbackEnabled: true,
            feedbackDecay: 0.68,
            feedbackOpacity: 0.6,
            feedbackZoom: 1.07,
            feedbackShiftX: -1,
            feedbackShiftY: 0
        }
        },
        {
            name: "004",
            settings: {
            fontSize: 255,
            duplications: 8,
            blur: 1,
            rotationSpeed: 3,
            distortion: 546,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "spiral",
            fontType: "sans-serif",
            feedbackEnabled: false,
            feedbackDecay: 0.68,
            feedbackOpacity: 0.6,
            feedbackZoom: 1.07,
            feedbackShiftX: -1,
            feedbackShiftY: 0
        }
        },
        {
            name: "005",
            settings: {
            fontSize: 81,
            duplications: 7,
            blur: 50,
            rotationSpeed: 9,
            distortion: 975,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "glitch",
            fontType: "sans-serif",
            feedbackEnabled: false,
            feedbackDecay: 0.6,
            feedbackOpacity: 0.1,
            feedbackZoom: 1.07,
            feedbackShiftX: -1,
            feedbackShiftY: 0
        }
        },
        {
            name: "006",
            settings: {
            fontSize: 94,
            duplications: 2,
            blur: 5,
            rotationSpeed: 5,
            distortion: 500,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "spiral",
            fontType: "sans-serif",
            feedbackEnabled: true,
            feedbackDecay: 0.8,
            feedbackOpacity: 0.58,
            feedbackZoom: 0.967,
            feedbackShiftX: -1,
            feedbackShiftY: 0
        }
        },
        {
            name: "007",
            settings: {
            fontSize: 153,
            duplications: 2,
            blur: 47,
            rotationSpeed: 6,
            distortion: 387,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "glitch",
            fontType: "sans-serif",
            feedbackEnabled: false,
            feedbackDecay: 0.68,
            feedbackOpacity: 0.6,
            feedbackZoom: 1.07,
            feedbackShiftX: -1,
            feedbackShiftY: 0
        }
        },
        {
            name: "008",
            settings: {
            fontSize: 349,
            duplications: 5,
            blur: 41,
            rotationSpeed: 1,
            distortion: 518,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "spiral",
            fontType: "sans-serif",
            feedbackEnabled: true,
            feedbackDecay: 0.87,
            feedbackOpacity: 0.49,
            feedbackZoom: 0.96,
            feedbackShiftX: 0,
            feedbackShiftY: 0
        }
        },
        {
            name: "009",
            settings: {
            fontSize: 119,
            duplications: 4,
            blur: 21,
            rotationSpeed: 8,
            distortion: 546,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "wave",
            fontType: "sans-serif",
            feedbackEnabled: true,
            feedbackDecay: 0.87,
            feedbackOpacity: 0.49,
            feedbackZoom: 0.96,
            feedbackShiftX: 0,
            feedbackShiftY: 0
        }
        },
        {
            name: "010",
            settings: {
            fontSize: 119,
            duplications: 4,
            blur: 21,
            rotationSpeed: 8,
            distortion: 0,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "wave",
            fontType: "sans-serif",
            feedbackEnabled: true,
            feedbackDecay: 0.87,
            feedbackOpacity: 0.49,
            feedbackZoom: 0.96,
            feedbackShiftX: 0,
            feedbackShiftY: 0
        }
        },
        {
            name: "011",
            settings: {
            fontSize: 256,
            duplications: 4,
            blur: 42,
            rotationSpeed: 1,
            distortion: 579,
            primaryColor: "#ffffff",
            secondaryColor: "#ffffff",
            effectType: "glitch",
            fontType: "sans-serif",
            feedbackEnabled: true,
            feedbackDecay: 0.9,
            feedbackOpacity: 0.49,
            feedbackZoom: 0.96,
            feedbackShiftX: 0,
            feedbackShiftY: 0
        }
        }
      ];

      // Set canvas dimensions
      function setCanvasDimensions() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Set dimensions for feedback canvas
        feedbackCanvas.width = window.innerWidth;
        feedbackCanvas.height = window.innerHeight;
        
      }
      
      setCanvasDimensions();

      // First, remove any existing toggle buttons to prevent duplicates
      const existingToggleButtons = document.querySelectorAll('.toggle-controls-panel');
      existingToggleButtons.forEach(button => {
        if (button) button.remove();
      });

      // Get control elements
      const controlsPanel = document.querySelector('.controls');

      // Create a single toggle button
      const toggleControlsBtn = document.createElement('div');
      toggleControlsBtn.className = 'toggle-controls-panel';
      toggleControlsBtn.textContent = 'C';
      document.body.appendChild(toggleControlsBtn);

      // Update toggle button position based on panel state
      function updateTogglePosition() {
        if (controlsPanel.classList.contains('hidden')) {
          toggleControlsBtn.style.right = '20px';
        } else {
          const controlsWidth = controlsPanel.offsetWidth;
          toggleControlsBtn.style.right = (controlsWidth + 30) + 'px';
        }
      }

      // Toggle controls panel
      toggleControlsBtn.addEventListener('click', () => {
        controlsPanel.classList.toggle('hidden');
        toggleControlsBtn.classList.toggle('panel-hidden');
        updateTogglePosition();
        
        // Save the state to localStorage
        localStorage.setItem('controlsPanelHidden', controlsPanel.classList.contains('hidden'));
      });

      // Check if the controls panel was hidden in the previous session
      const wasPanelHidden = localStorage.getItem('controlsPanelHidden') === 'true';
      if (wasPanelHidden) {
        controlsPanel.classList.add('hidden');
        toggleControlsBtn.classList.add('panel-hidden');
      }

      window.addEventListener('resize', () => {
        setCanvasDimensions();
        updateTogglePosition();
      });

      // Mouse move event
      window.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      if (isMobile) {
        // Create a button to request permission on iOS (required for iOS 13+)
        if (typeof DeviceOrientationEvent !== 'undefined' && 
            typeof DeviceOrientationEvent.requestPermission === 'function') {
          
          const permissionBtn = document.createElement('button');
          permissionBtn.textContent = 'Enable Gyroscope';
          permissionBtn.style.position = 'fixed';
          permissionBtn.style.top = '50%';
          permissionBtn.style.left = '50%';
          permissionBtn.style.transform = 'translate(-50%, -50%)';
          permissionBtn.style.zIndex = '1000';
          permissionBtn.style.padding = '12px 24px';
          permissionBtn.style.backgroundColor = '#333';
          permissionBtn.style.color = 'white';
          permissionBtn.style.border = 'none';
          permissionBtn.style.borderRadius = '4px';
          permissionBtn.style.fontSize = '16px';
          
          permissionBtn.addEventListener('click', () => {
            DeviceOrientationEvent.requestPermission()
              .then(response => {
                if (response === 'granted') {
                  window.addEventListener('deviceorientation', handleOrientation);
                  hasGyro = true;
                  document.body.removeChild(permissionBtn);
                  showNotification('Gyroscope enabled');
                }
              })
              .catch(console.error);
          });
          
          document.body.appendChild(permissionBtn);
        } else {
          // For non-iOS devices or older iOS versions
          window.addEventListener('deviceorientation', handleOrientation);
          hasGyro = true;
        }
      }

      function applyDefaultPreset() {
        // Apply the "Unsure" preset by default
        const unsurePreset = builtinPresets.find(preset => preset.name === "Unsure");
        if (unsurePreset) {
          applySettings(unsurePreset.settings);
          showNotification("Default preset 'Unsure' applied");
        }
      }

      // Call this after all your initialization
      applyDefaultPreset();

      // Handle orientation data
      function handleOrientation(event) {
        // Normalize gyroscope data
        gyroData.beta = event.beta;  // Front/back tilt: -180 to 180
        gyroData.gamma = event.gamma; // Left/right tilt: -90 to 90
      }                                    

      // Function to convert hex color to RGB array
      function hexToRgb(hex) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return [r, g, b];
      }
      
      // Function to convert RGB array to hex color
      function rgbToHex(r, g, b) {
        return `#${Math.floor(r).toString(16).padStart(2, '0')}${Math.floor(g).toString(16).padStart(2, '0')}${Math.floor(b).toString(16).padStart(2, '0')}`;
      }
      
      // Function to interpolate between two colors
      function interpolateColor(color1, color2, factor) {
        const rgb1 = hexToRgb(color1);
        const rgb2 = hexToRgb(color2);
        
        const r = rgb1[0] + factor * (rgb2[0] - rgb1[0]);
        const g = rgb1[1] + factor * (rgb2[1] - rgb1[1]);
        const b = rgb1[2] + factor * (rgb2[2] - rgb1[2]);
        
        return rgbToHex(r, g, b);
      }
      
      // Function to show notification
      function showNotification(message) {
        notification.textContent = message;
        notification.classList.add('show');
        setTimeout(() => {
          notification.classList.remove('show');
        }, 2000);
      }

      function isAnyMenuItemActive() {
        const activeMenuItems = document.querySelectorAll('.menu-item.active');
        return activeMenuItems.length > 0;
      }

      // Function to check if click is on the canvas area
      function isAnyMenuItemActive() {
        const activeMenuItems = document.querySelectorAll('.menu-item.active');
        return activeMenuItems.length > 0;
      }

      // Function to check if click is on the canvas area
      function isCanvasAreaClick(element) {
        // Consider clicks only on the canvas elements or the direct canvas container
        const canvasContainer = document.getElementById('canvas-container');
        const typographyCanvas = document.getElementById('typography-canvas');
        const feedbackCanvas = document.getElementById('feedback-canvas');
        
        // Check if the click is directly on the canvas or its container
        if (element === typographyCanvas || 
            element === feedbackCanvas || 
            element === canvasContainer) {
          return true;
        }
        
        // Also consider clicks on the body that aren't on any specific UI element
        // This is a fallback in case canvas containers are restructured
        if (element === document.body) {
          return true;
        }
        
        return false;
      }

      // Variable to track the last applied random preset
      let lastAppliedRandomPreset = "Unsure"; // Start with the default

      // Function to pick a random preset from 001-011 + Unsure
      function getRandomPreset() {
        // Create an array with all preset names including "Unsure"
        const presetNames = ["Unsure"];
        
        // Add numbered presets from 001 to 011
        const numberedPresets = builtinPresets
          .filter(preset => /^0\d{2}$/.test(preset.name)) // Filter presets with names like "001", "002", etc.
          .map(preset => preset.name);
        
        presetNames.push(...numberedPresets);
        
        // If no numbered presets found, fall back to finding by index in the built-in presets
        if (numberedPresets.length === 0) {
          for (let i = 7; i <= 17; i++) { // Approximate indices based on the preset list
            if (builtinPresets[i] && builtinPresets[i].name) {
              presetNames.push(builtinPresets[i].name);
            }
          }
        }
        
        // Filter out the last applied preset to prevent repetition
        const availablePresets = presetNames.filter(name => name !== lastAppliedRandomPreset);
        
        // If somehow all presets were filtered out (shouldn't happen unless there's only one preset), 
        // use the full list again
        const presetsToChooseFrom = availablePresets.length > 0 ? availablePresets : presetNames;
        
        // Pick a random preset name from the filtered array
        const randomIndex = Math.floor(Math.random() * presetsToChooseFrom.length);
        return presetsToChooseFrom[randomIndex];
      }

      // Add click event listener to the document
      document.addEventListener('click', (event) => {
        // Only proceed if no menu item is active
        if (!isAnyMenuItemActive()) {
          // Check if the click is on the canvas area
          if (isCanvasAreaClick(event.target)) {
            // Get and apply a random preset
            const randomPreset = getRandomPreset();
            applyPresetByName(randomPreset);
            
            // Update the text back to default if it's been changed
            updateCanvasText("EN5EMBLE");
            
            // Remember this preset to avoid repeating it next time
            lastAppliedRandomPreset = randomPreset;
          }
        }
      });

      // Apply feedback effect
      function applyFeedback() {
        // Skip frames for performance if needed
        frameCount++;
        
        // Save current transformation state
        feedbackCtx.save();
        
        // Apply fade effect by drawing a semi-transparent black rectangle
        feedbackCtx.fillStyle = `rgba(0, 0, 0, ${feedbackDecay})`;
        feedbackCtx.fillRect(0, 0, feedbackCanvas.width, feedbackCanvas.height);
        
        // Set the composite operation to only show brighter parts
        feedbackCtx.globalCompositeOperation = 'lighter';
        
        // Calculate center for transformations
        const centerX = feedbackCanvas.width / 2;
        const centerY = feedbackCanvas.height / 2;
        
        // Apply transformations relative to center
        feedbackCtx.translate(centerX, centerY);
        feedbackCtx.scale(feedbackZoom, feedbackZoom);
        feedbackCtx.translate(-centerX + feedbackShiftX, -centerY + feedbackShiftY);
        
        // Draw the current canvas onto the feedback canvas with opacity
        feedbackCtx.globalAlpha = feedbackOpacity;
        feedbackCtx.drawImage(canvas, 0, 0);
        
        // Restore the context state
        feedbackCtx.restore();
      }
      
      // Function to get current settings
      function getCurrentSettings() {
        return {
          fontSize: parseInt(fontSizeControl.value),
          duplications: parseInt(duplicationsControl.value),
          blur: parseInt(blurControl.value),
          rotationSpeed: parseFloat(rotationSpeedControl.value),
          distortion: parseInt(distortionControl.value),
          primaryColor: primaryColorControl.value,
          secondaryColor: secondaryColorControl.value,
          effectType: effectTypeControl.value,
          fontType: fontTypeControl.value,
          feedbackEnabled: feedbackEnabledControl.checked,
          feedbackDecay: parseFloat(feedbackDecayControl.value),
          feedbackOpacity: parseFloat(feedbackOpacityControl.value),
          feedbackZoom: parseFloat(feedbackZoomControl.value),
          feedbackShiftX: parseFloat(feedbackShiftXControl.value),
          feedbackShiftY: parseFloat(feedbackShiftYControl.value),
        };
      }
      
      // Function to apply settings from a preset
      function applySettings(settings) {
        // Save previous values for interpolation
        prevFontSize = fontSize;
        prevDuplications = duplications;
        prevBlur = blur;
        prevRotationSpeed = rotationSpeed;
        prevDistortion = distortion;
        prevPrimaryColor = primaryColor;
        prevSecondaryColor = secondaryColor;
        prevEffectType = effectType;
        prevFontType = fontType;
        
        // Set the UI controls to new values
        fontSizeControl.value = settings.fontSize;
        duplicationsControl.value = settings.duplications;
        blurControl.value = settings.blur;
        rotationSpeedControl.value = settings.rotationSpeed;
        distortionControl.value = settings.distortion;
        primaryColorControl.value = settings.primaryColor;
        secondaryColorControl.value = settings.secondaryColor;
        effectTypeControl.value = settings.effectType;
        fontTypeControl.value = fontSystem.getCompatibleFontName(settings.fontType);
        
        // Set target values for interpolation
        targetFontSize = settings.fontSize;
        targetDuplications = settings.duplications;
        targetBlur = settings.blur;
        targetRotationSpeed = settings.rotationSpeed;
        targetDistortion = settings.distortion;
        targetPrimaryColor = settings.primaryColor;
        targetSecondaryColor = settings.secondaryColor;
        targetEffectType = settings.effectType;
        targetFontType = settings.fontType;

        // Apply feedback settings if they exist in the preset
        if (settings.feedbackEnabled !== undefined) {
          feedbackEnabledControl.checked = settings.feedbackEnabled;
          feedbackEnabled = settings.feedbackEnabled;
        }
        
        if (settings.feedbackDecay !== undefined) {
          feedbackDecayControl.value = settings.feedbackDecay;
          feedbackDecay = settings.feedbackDecay;
        }
        
        if (settings.feedbackOpacity !== undefined) {
          feedbackOpacityControl.value = settings.feedbackOpacity;
          feedbackOpacity = settings.feedbackOpacity;
        }
        
        if (settings.feedbackZoom !== undefined) {
          feedbackZoomControl.value = settings.feedbackZoom;
          feedbackZoom = settings.feedbackZoom;
        }
        
        if (settings.feedbackShiftX !== undefined) {
          feedbackShiftXControl.value = settings.feedbackShiftX;
          feedbackShiftX = settings.feedbackShiftX;
        }
        
        if (settings.feedbackShiftY !== undefined) {
          feedbackShiftYControl.value = settings.feedbackShiftY;
          feedbackShiftY = settings.feedbackShiftY;
        }

        if (feedbackCanvas && feedbackCtx) {
          feedbackCtx.clearRect(0, 0, feedbackCanvas.width, feedbackCanvas.height);
        }

        // Start interpolation
        isInterpolating = true;
        interpolationStartTime = Date.now();
      }
      
      // Animation function
      function animate() {
        if (!isAnimating) return;

        if (!canvas || !ctx) {
          console.error("Cannot animate: canvas or context is missing");
          isAnimating = false;
          return;
        }
              
        // Handle interpolation
        if (isInterpolating) {
          const currentTime = Date.now();
          const elapsed = currentTime - interpolationStartTime;
          let progress = Math.min(elapsed / interpolationDuration, 1);
          
          // Ease in-out function for smoother transitions
          progress = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;
          
          // Interpolate numeric values
          fontSize = Math.round(prevFontSize + (targetFontSize - prevFontSize) * progress);
          duplications = Math.round(prevDuplications + (targetDuplications - prevDuplications) * progress);
          blur = Math.round(prevBlur + (targetBlur - prevBlur) * progress);
          rotationSpeed = prevRotationSpeed + (targetRotationSpeed - prevRotationSpeed) * progress;
          distortion = Math.round(prevDistortion + (targetDistortion - prevDistortion) * progress);
          
          // Interpolate colors
          primaryColor = interpolateColor(prevPrimaryColor, targetPrimaryColor, progress);
          secondaryColor = interpolateColor(prevSecondaryColor, targetSecondaryColor, progress);
          
          // For effect type and font type, we switch immediately at the midpoint of interpolation
          if (progress >= 0.5) {
            effectType = targetEffectType;
            fontType = targetFontType;
          }
          
          // Update UI controls to reflect current interpolated values
          fontSizeControl.value = fontSize;
          duplicationsControl.value = duplications;
          blurControl.value = blur;
          rotationSpeedControl.value = rotationSpeed;
          distortionControl.value = distortion;
          primaryColorControl.value = primaryColor;
          secondaryColorControl.value = secondaryColor;
          
          // End interpolation when complete
          if (progress >= 1) {
            isInterpolating = false;
            effectType = targetEffectType;
            fontType = targetFontType;
          }
        }
        
        if (feedbackEnabled) {
          applyFeedback();
        }

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Update time
        time += 0.01 * rotationSpeed;
        
        // Apply canvas-level blur if needed
        if (blur > 0) {
          ctx.filter = `blur(${blur / 5}px)`;
        } else {
          ctx.filter = 'none';
        }
        
        // Calculate center position
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // Replace with this code:
        let inputX, inputY;

        if (isMobile && hasGyro) {
          // Use gyroscope data
          // Map gamma (-90 to 90) to canvas width with increased sensitivity for better effect
          inputX = centerX + (gyroData.gamma / 30) * centerX;
          // Map beta (-180 to 180) to canvas height with a limited range for better control
          inputY = centerY + (Math.max(-30, Math.min(30, gyroData.beta)) / 30) * centerY;
        } else {
          // Use mouse data on desktop
          inputX = mouseX;
          inputY = mouseY;
        }

        const inputInfluenceX = (inputX - centerX) / centerX * distortion;
        const inputInfluenceY = (inputY - centerY) / centerY * distortion;
        
        // Set text properties
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Draw each duplication
        for (let i = 0; i < duplications; i++) {
          const progress = i / duplications;
          const angle = time + progress * Math.PI * 2;
          
          // Color gradient based on progress
          const ratio = progress;
          const color = interpolateColor(primaryColor, secondaryColor, ratio);
          ctx.fillStyle = color;
          
          // Apply effect-specific transformations
          ctx.save();
          
          // Base position influenced by mouse
          let xPos = centerX + inputInfluenceX * Math.sin(progress * Math.PI * 2);
          let yPos = centerY + inputInfluenceY * Math.cos(progress * Math.PI * 2);
          
          let scaleFactor = 1;
          let rotationAngle = angle * rotationSpeed;
          
          switch (effectType) {
            case 'wave':
              xPos += Math.sin(time * 2 + progress * Math.PI * 4) * distortion;
              yPos += Math.cos(time * 2 + progress * Math.PI * 4) * distortion;
              break;
              
            case 'fracture':
              xPos += (Math.random() - 0.5) * distortion * 2;
              yPos += (Math.random() - 0.5) * distortion * 2;
              rotationAngle += (Math.random() - 0.5) * distortion / 100;
              break;
              
            case 'spiral':
              const spiralRadius = progress * distortion * 2;
              xPos += Math.cos(angle * 3) * spiralRadius;
              yPos += Math.sin(angle * 3) * spiralRadius;
              break;
              
            case 'glitch':
              if (Math.random() > 0.7) {
                xPos += (Math.random() - 0.5) * distortion * 4;
                ctx.filter = `blur(${Math.random() * blur / 2}px) contrast(${1 + Math.random()})`;
              }
              break;
          }
          
          // Apply transforms
          ctx.translate(xPos, yPos);
          ctx.rotate(rotationAngle);
          ctx.scale(1 + progress * 0.2, 1 + progress * 0.2);
          
          let displayFontSize = fontSize;
          if (isMobile) {
            displayFontSize = Math.floor(fontSize * mobileFontScaleFactor);
          }

          // Draw text with mobile-adjusted font size
          ctx.font = `${displayFontSize}px ${fontSystem.getFontFamily(fontType)}`;
          ctx.fillText(text, 0, 0);
          
          ctx.restore();
        }
        
        ctx.globalCompositeOperation = 'destination-over';
        ctx.drawImage(feedbackCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
      
        requestAnimationFrame(animate);
      }
      
      // Function to generate preset code
      function generatePresetCode(preset) {
        return JSON.stringify(preset);
      }
      
      // Function to generate embeddable code
      function generateEmbeddableCode() {
        const settings = getCurrentSettings();
        const codeObj = {
          type: "TYPO_001_PRESET",
          version: "1.0",
          preset: {
            name: presetNameInput.value.trim() || "Unnamed Preset",
            settings: settings
          }
        };
        
        // Format as JavaScript code that can be pasted directly into source
        const presetStr = JSON.stringify(codeObj.preset, null, 2);
        return `
    // -------- Typography Preset Code --------
    // Add this to the builtinPresets array in your source code
    const customPreset = ${presetStr};
    // builtinPresets.push(customPreset);
    // ----------------------------------------
    `;
      }
      
      // Function to create preset element
      function createPresetElement(preset, isBuiltin = false) {
        const presetItem = document.createElement('div');
        presetItem.className = 'preset-item';
        
        const presetName = document.createElement('span');
        presetName.textContent = preset.name;
        presetItem.appendChild(presetName);
        
        const presetActions = document.createElement('div');
        presetActions.className = 'preset-actions';
        
        const loadBtn = document.createElement('button');
        loadBtn.textContent = 'Load';
        loadBtn.addEventListener('click', () => {
          applySettings(preset.settings);
          showNotification(`Loaded preset: ${preset.name}`);
        });
        presetActions.appendChild(loadBtn);
        
        if (!isBuiltin) {
          const deleteBtn = document.createElement('button');
          deleteBtn.textContent = 'Delete';
          deleteBtn.addEventListener('click', () => {
            userPresets = userPresets.filter(p => p.name !== preset.name);
            localStorage.setItem('typographyPresets', JSON.stringify(userPresets));
            renderUserPresets();
            showNotification(`Deleted preset: ${preset.name}`);
          });
          presetActions.appendChild(deleteBtn);
        }
        
        const codeBtn = document.createElement('button');
        codeBtn.textContent = 'Code';
        codeBtn.addEventListener('click', () => {
          // Save the preset name for code generation
          presetNameInput.value = preset.name;
          presetCodeTextarea.value = generateEmbeddableCode();
          showNotification(`Generated code for preset: ${preset.name}`);
        });
        presetActions.appendChild(codeBtn);
        
        presetItem.appendChild(presetActions);
        return presetItem;
      }
      
      // Function to render user presets
      function renderUserPresets() {
        userPresetList.innerHTML = '';
        
        if (userPresets.length === 0) {
          const emptyMessage = document.createElement('div');
          emptyMessage.textContent = 'No saved presets yet';
          emptyMessage.style.padding = '5px';
          emptyMessage.style.opacity = '0.7';
          userPresetList.appendChild(emptyMessage);
          return;
        }
        
        userPresets.forEach(preset => {
          const presetElement = createPresetElement(preset);
          userPresetList.appendChild(presetElement);
        });
      }
      
      // Function to render builtin presets
      function renderBuiltinPresets() {
        builtinPresetList.innerHTML = '';
        
        builtinPresets.forEach(preset => {
          const presetElement = createPresetElement(preset, true);
          builtinPresetList.appendChild(presetElement);
        });
      }
      
      // Initialize preset lists
      renderUserPresets();
      renderBuiltinPresets();
      
      // Toggle preset panel
      togglePresetPanel.addEventListener('click', () => {
        presetPanel.classList.toggle('open');
      });

      if (feedbackEnabledControl) {
        feedbackEnabledControl.addEventListener('change', () => {
          feedbackEnabled = feedbackEnabledControl.checked;
          
          // Clear the feedback canvas if disabled
          if (!feedbackEnabled) {
            feedbackCtx.clearRect(0, 0, feedbackCanvas.width, feedbackCanvas.height);
          }
        });
      }
      
      if (feedbackDecayControl) {
        feedbackDecayControl.addEventListener('input', () => {
          feedbackDecay = parseFloat(feedbackDecayControl.value);
        });
      }
      
      if (feedbackOpacityControl) {
        feedbackOpacityControl.addEventListener('input', () => {
          feedbackOpacity = parseFloat(feedbackOpacityControl.value);
        });
      }
      
      if (feedbackZoomControl) {
        feedbackZoomControl.addEventListener('input', () => {
          feedbackZoom = parseFloat(feedbackZoomControl.value);
        });
      }
      
      if (feedbackShiftXControl) {
        feedbackShiftXControl.addEventListener('input', () => {
          feedbackShiftX = parseFloat(feedbackShiftXControl.value);
        });
      }
      
      if (feedbackShiftYControl) {
        feedbackShiftYControl.addEventListener('input', () => {
          feedbackShiftY = parseFloat(feedbackShiftYControl.value);
        });
      }

      // Save current settings as preset
      saveCurrentBtn.addEventListener('click', () => {
        const presetName = presetNameInput.value.trim();
        if (!presetName) {
          showNotification('Please enter a preset name');
          return;
        }
        
        // Check if name already exists
        const existingIndex = userPresets.findIndex(p => p.name === presetName);
        
        const newPreset = {
          name: presetName,
          settings: getCurrentSettings()
        };
        
        if (existingIndex >= 0) {
          // Update existing preset
          userPresets[existingIndex] = newPreset;
          showNotification(`Updated preset: ${presetName}`);
        } else {
          // Add new preset
          userPresets.push(newPreset);
          showNotification(`Saved preset: ${presetName}`);
        }
        
        localStorage.setItem('typographyPresets', JSON.stringify(userPresets));
        renderUserPresets();
        presetNameInput.value = '';
      });
      
      // Generate code for current settings
      generateCodeBtn.addEventListener('click', () => {
        const presetName = presetNameInput.value.trim() || 'Unnamed Preset';
        
        // Generate embeddable code instead of just the JSON
        presetCodeTextarea.value = generateEmbeddableCode();
        presetCodeTextarea.select();
        showNotification('Code generated! Copy to paste into source');
      });
      
      // Export preset
      exportPresetBtn.addEventListener('click', () => {
        const presetName = presetNameInput.value.trim() || 'Exported Preset';
        
        const preset = {
          name: presetName,
          settings: getCurrentSettings()
        };
        
        presetCodeTextarea.value = generatePresetCode(preset);
        presetCodeTextarea.select();
        document.execCommand('copy');
        showNotification('Preset code copied to clipboard!');
      });
      
      // Import preset
      importPresetBtn.addEventListener('click', () => {
        const code = presetCodeTextarea.value.trim();
        if (!code) {
          showNotification('Please enter preset code');
          return;
        }
        
        try {
          // Try to parse as direct JSON first
          let preset;
          
          try {
            preset = JSON.parse(code);
          } catch (e) {
            // If that fails, try to extract JSON from embedded code format
            const jsonMatch = code.match(/const\s+customPreset\s+=\s+({[\s\S]*?});/);
            if (jsonMatch && jsonMatch[1]) {
              preset = JSON.parse(jsonMatch[1]);
            } else {
              throw new Error('Could not parse preset code');
            }
          }
          
          if (!preset.name || !preset.settings) {
            throw new Error('Invalid preset format');
          }
          
          applySettings(preset.settings);
          showNotification(`Imported preset: ${preset.name}`);
          
          // Ask if user wants to save this imported preset
          if (confirm(`Do you want to save the imported preset "${preset.name}" to your collection?`)) {
            const existingIndex = userPresets.findIndex(p => p.name === preset.name);
            
            if (existingIndex >= 0) {
              // Update existing preset
              userPresets[existingIndex] = preset;
            } else {
              // Add new preset
              userPresets.push(preset);
            }
            
            localStorage.setItem('typographyPresets', JSON.stringify(userPresets));
            renderUserPresets();
          }
          
          presetCodeTextarea.value = '';
        } catch (error) {
          showNotification('Invalid preset code');
          console.error(error);
        }
      });
      
      // Save preset button in the main controls
      savePresetBtn.addEventListener('click', () => {
        presetPanel.classList.add('open');
        presetNameInput.focus();
      });
      
      // Handle control changes
      if (textInput) {
        textInput.addEventListener('input', () => text = textInput.value);
      }
      fontSizeControl.addEventListener('input', () => {
        targetFontSize = parseInt(fontSizeControl.value);
        if (!isInterpolating) fontSize = targetFontSize;
      });
      duplicationsControl.addEventListener('input', () => {
        targetDuplications = parseInt(duplicationsControl.value);
        if (!isInterpolating) duplications = targetDuplications;
      });
      blurControl.addEventListener('input', () => {
        targetBlur = parseInt(blurControl.value);
        if (!isInterpolating) blur = targetBlur;
      });
      rotationSpeedControl.addEventListener('input', () => {
        targetRotationSpeed = parseFloat(rotationSpeedControl.value);
        if (!isInterpolating) rotationSpeed = targetRotationSpeed;
      });
      distortionControl.addEventListener('input', () => {
        targetDistortion = parseInt(distortionControl.value);
        if (!isInterpolating) distortion = targetDistortion;
      });
      primaryColorControl.addEventListener('input', () => {
        targetPrimaryColor = primaryColorControl.value;
        if (!isInterpolating) primaryColor = targetPrimaryColor;
      });
      secondaryColorControl.addEventListener('input', () => {
        targetSecondaryColor = secondaryColorControl.value;
        if (!isInterpolating) secondaryColor = targetSecondaryColor;
      });
      effectTypeControl.addEventListener('change', () => {
        targetEffectType = effectTypeControl.value;
        if (!isInterpolating) effectType = targetEffectType;
      });
      fontTypeControl.addEventListener('change', () => {
        targetFontType = fontTypeControl.value;
        if (!isInterpolating) fontType = targetFontType;
      });
      transitionTimeControl.addEventListener('input', () => {
        transitionTime = parseFloat(transitionTimeControl.value);
        interpolationDuration = transitionTime * 1000;
      });
      
      // Randomize settings
      randomizeBtn.addEventListener('click', () => {
        // Save previous values
        prevFontSize = fontSize;
        prevDuplications = duplications;
        prevBlur = blur;
        prevRotationSpeed = rotationSpeed;
        prevDistortion = distortion;
        prevPrimaryColor = primaryColor;
        prevSecondaryColor = secondaryColor;
        prevEffectType = effectType;
        prevFontType = fontType;
        
        // Generate new random target values
        fontSizeControl.value = Math.floor(Math.random() * 350 + 50);
        duplicationsControl.value = Math.floor(Math.random() * 9 + 1);
        blurControl.value = Math.floor(Math.random() * 50);
        rotationSpeedControl.value = Math.floor(Math.random() * 10 + 1);
        distortionControl.value = Math.floor(Math.random() * 1000);
        
        // Random effect and font
        const effects = ['wave', 'fracture', 'spiral', 'glitch'];
        
        effectTypeControl.value = effects[Math.floor(Math.random() * effects.length)];
        
        // Set target values
        targetFontSize = parseInt(fontSizeControl.value);
        targetDuplications = parseInt(duplicationsControl.value);
        targetBlur = parseInt(blurControl.value);
        targetRotationSpeed = parseFloat(rotationSpeedControl.value);
        targetDistortion = parseInt(distortionControl.value);
        targetEffectType = effectTypeControl.value;
        
        // Start interpolation
        isInterpolating = true;
        interpolationStartTime = Date.now();
      });
      
      // Start animation
      animate();

      // Setup menu
      setupMenu();
      // Check if URL has a hash and select the corresponding menu item
      checkUrlHash();

      //mixxs soudcloud
      // Modify the existing menu click handler for mixxs
      if (mixxsMenuItem) {
        mixxsMenuItem.addEventListener('click', (e) => {
          // If mixxs section becomes active, show the gallery
          if (mixxsMenuItem.classList.contains('active')) {
            loadMixesContent();
            mixesGallery.classList.add('active');
          } else {
            mixesGallery.classList.remove('active');
          }
        });
      }

      // Function to load mixes content from the server
      async function loadMixesContent() {
        try {
          // Show loading state
          mixesContainer.innerHTML = '<div style="color: white; text-align: center; padding: 50px;">Loading mixes...</div>';
          
          // Fetch mixes from the server
          const response = await fetch('/api/mixes');
          const data = await response.json();
          
          // Clear loading message
          mixesContainer.innerHTML = '';
          
          if (!data.mixes || data.mixes.length === 0) {
            mixesContainer.innerHTML = '<div style="color: white; text-align: center; padding: 50px;">No mixes found. Add tracks to the mixes.json file.</div>';
            return;
          }
          
          // Create and append mix elements with index
          data.mixes.forEach((mix, index) => {
            const mixElement = createMixElement(mix, index);
            mixesContainer.appendChild(mixElement);
          });
          
          // Add parallax effect for desktop only
          if (window.innerWidth >= 768) {
            setupParallaxEffect();
          }
        } catch (error) {
          console.error('Error loading mixes:', error);
          mixesContainer.innerHTML = '<div style="color: white; text-align: center; padding: 50px;">Error loading mixes. Please try again later.</div>';
        }
      }

      function setupParallaxEffect() {
        const mixesGallery = document.getElementById('mixes-gallery');
        
        mixesGallery.addEventListener('mousemove', (e) => {
          // Only apply on desktop
          if (window.innerWidth < 768) return;
          
          const containers = document.querySelectorAll('.mix-container');
          const mouseX = e.clientX / window.innerWidth - 0.5; // -0.5 to 0.5
          const mouseY = e.clientY / window.innerHeight - 0.5; // -0.5 to 0.5
          
          containers.forEach((container, index) => {
            // Calculate a different intensity for each container
            const intensity = 10 + (index % 3) * 5; // Varies between 10, 15, 20
            
            // Apply transform based on mouse position
            container.style.transform = `
              translateX(${mouseX * intensity}px) 
              translateY(${mouseY * intensity}px)
              rotate(${container.style.getPropertyValue('--rotation') || '0deg'})
            `;
          });
        });
        
        // Reset positions when mouse leaves
        mixesGallery.addEventListener('mouseleave', () => {
          const containers = document.querySelectorAll('.mix-container');
          
          containers.forEach((container) => {
            container.style.transform = `rotate(${container.style.getPropertyValue('--rotation') || '0deg'})`;
          });
        });
      }

      window.addEventListener('resize', function() {
        // If we resize to mobile, remove any desktop styling
        if (window.innerWidth < 768) {
          const containers = document.querySelectorAll('.mix-container');
          containers.forEach(container => {
            container.style.transform = '';
            container.style.animation = '';
            container.style.opacity = '1';
          });
        }
      });

      // Function to create a mix element with Soundcloud embed
      function createMixElement(mix, index) {
        const mixElement = document.createElement('div');
        mixElement.className = 'mix-container';
        
        // Only add special effects for desktop
        if (window.innerWidth >= 768) {
          // Add random rotation variable for animation
          const randomRotation = (Math.random() * 2 - 1) * 1.5; // Between -1.5 and 1.5 degrees
          mixElement.style.setProperty('--rotation', `${randomRotation}deg`);
          
          // Add animation with delay based on index
          mixElement.style.animation = `fadeSlideIn 0.5s ease forwards ${index * 0.15}s`;
          mixElement.style.opacity = '0'; // Start invisible for animation
        }
        
        // Add title element
        const titleElement = document.createElement('h2');
        titleElement.className = 'mix-title';
        titleElement.textContent = mix.title || 'Untitled Mix';
        mixElement.appendChild(titleElement);
        
        // Create metadata element (artist and date)
        const metadataElement = document.createElement('div');
        metadataElement.className = 'mix-metadata';
        
        // Format the date nicely
        const mixDate = new Date(mix.date);
        const formattedDate = mixDate.toLocaleDateString(undefined, {
          year: 'numeric',
          month: 'short',
          day: 'numeric'
        });
        
        // Show artist and date
        metadataElement.textContent = `${mix.artist} • ${formattedDate}`;
        mixElement.appendChild(metadataElement);
        
        // Create Soundcloud embed
        const embedContainer = document.createElement('div');
        embedContainer.className = 'soundcloud-embed';
        
        // Use the provided embed code
        if (mix.embedCode) {
          embedContainer.innerHTML = mix.embedCode;
        } else if (mix.soundcloudUrl || mix.soundcloudId) {
          // Create iframe for Soundcloud embed (fallback method)
          const iframe = document.createElement('iframe');
          iframe.width = '100%';
          iframe.height = '200';
          iframe.scrolling = 'no';
          iframe.frameBorder = 'no';
          iframe.allow = 'autoplay';
          
          if (mix.soundcloudId) {
            iframe.src = `https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/${mix.soundcloudId}&color=%23ffff00&auto_play=false&hide_related=true&show_comments=false&show_user=true&show_reposts=false&show_teaser=false&visual=true`;
          } else if (mix.soundcloudUrl) {
            const encodedUrl = encodeURIComponent(mix.soundcloudUrl);
            iframe.src = `https://w.soundcloud.com/player/?url=${encodedUrl}&color=%23ffff00&auto_play=false&hide_related=true&show_comments=false&show_user=true&show_reposts=false&show_teaser=false&visual=true`;
          }
          
          embedContainer.appendChild(iframe);
        }
        
        mixElement.appendChild(embedContainer);
        
        return mixElement;
      }

      // Check if mixxs is already active on page load
      if (mixxsMenuItem && mixxsMenuItem.classList.contains('active')) {
        loadMixesContent();
        mixesGallery.classList.add('active');
      }

      function setupMenu() {
        const menuItems = document.querySelectorAll('.menu-item');
        const archiveGallery = document.getElementById('archive-gallery');
        const mixesGallery = document.getElementById('mixes-gallery'); // Add this line
        
        // Menu item click handler
        menuItems.forEach(item => {
          item.addEventListener('click', (e) => {
            e.preventDefault();
            
            const clickedItem = e.target;
            const parentLi = clickedItem.parentElement;
            const section = clickedItem.getAttribute('data-section');
            
            // Check if we're clicking on a menu item that's not "archives" or "mixxs"
            // If so, make sure both galleries are closed
            if (section !== 'archives' && archiveGallery.classList.contains('active')) {
              archiveGallery.classList.remove('active');
            }
            
            if (section !== 'mixxs' && mixesGallery.classList.contains('active')) {
              mixesGallery.classList.remove('active');
            }
            
            // Toggle active state or update URL
            if (clickedItem.classList.contains('active')) {
              // If already active, deactivate and clear URL hash
              clickedItem.classList.remove('active');
              parentLi.classList.remove('active-item');
              history.pushState(null, '', window.location.pathname); // Remove hash from URL
              
              // Apply default preset when deselecting and set default text
              applyPresetByName("Unsure");
              updateCanvasText("EN5EMBLE");
            } else {
              // First, remove active class from all items
              menuItems.forEach(i => {
                i.classList.remove('active');
                i.parentElement.classList.remove('active-item');
              });
              
              // Then, add active class to clicked item
              clickedItem.classList.add('active');
              parentLi.classList.add('active-item');
              
              // Update URL without navigation - using History API
              history.pushState(null, '', `#${section}`);
              
              // Apply corresponding preset and text
              applyPresetForSection(section);
            }
            
            // Simple feedback animation
            const originalColor = window.getComputedStyle(clickedItem).color;
            clickedItem.style.color = '#ffffff';
            
            setTimeout(() => {
              clickedItem.style.color = '';
            }, 200);
            
            console.log(`Selected section: ${section}`);
          });
        });
      }
      
      // Check URL hash on page load and set the active menu item
      function checkUrlHash() {
        const archiveGallery = document.getElementById('archive-gallery');
        const mixesGallery = document.getElementById('mixes-gallery'); // Add this line
        
        // First, clear all active states
        const allMenuItems = document.querySelectorAll('.menu-item');
        allMenuItems.forEach(item => {
          item.classList.remove('active');
          item.parentElement.classList.remove('active-item');
        });
        
        // Then, if there's a hash, find and activate the corresponding menu item
        if (window.location.hash) {
          const section = window.location.hash.substring(1); // Remove the # character
          const menuItem = document.querySelector(`.menu-item[data-section="${section}"]`);
          
          // Close the archive gallery if we're not on the archives section
          if (section !== 'archives' && archiveGallery.classList.contains('active')) {
            archiveGallery.classList.remove('active');
          }
          
          // Close the mixes gallery if we're not on the mixxs section
          if (section !== 'mixxs' && mixesGallery.classList.contains('active')) {
            mixesGallery.classList.remove('active');
          }
          
          if (menuItem) {
            menuItem.classList.add('active');
            menuItem.parentElement.classList.add('active-item');
            
            // Apply the corresponding preset
            applyPresetForSection(section);
          }
        } else {
          // If no hash, apply the default "Unsure" preset
          applyPresetByName("Unsure");
          
          // Also ensure galleries are closed when there's no hash
          if (archiveGallery.classList.contains('active')) {
            archiveGallery.classList.remove('active');
          }
          
          if (mixesGallery.classList.contains('active')) {
            mixesGallery.classList.remove('active');
          }
        }
      } 
      
      // Function to apply a preset based on the selected section
      function applyPresetForSection(section) {
        // Map sections to preset names and corresponding text
        const sectionMap = {
          "events": {
            preset: "Beacon of truth",
            text: "EVENTS EN5EMBLE"
          },
          "mixxs": {
            preset: "Skeud",
            text: "MIXxxxxxES"
          },
          "archives": {
            preset: "Archives",
            text: "archives"
          },
          "contact": {
            preset: "Equilibrium",
            text: "@EN5EMBLE"
          }
        };
        
        const mapping = sectionMap[section] || { preset: "Unsure", text: "EN5EMBLE" };
        
        // Apply the preset
        applyPresetByName(mapping.preset);
        
        // Update the text
        updateCanvasText(mapping.text);
      }
      
      // Function to update the canvas text
      function updateCanvasText(newText) {
        const textInput = document.getElementById('text-content');
        if (textInput) {
          textInput.value = newText;
          // Trigger the input event to update the canvas
          const event = new Event('input', { bubbles: true });
          textInput.dispatchEvent(event);
        }
      }
      
      // Function to find and apply a preset by name
      function applyPresetByName(presetName) {
        // First check built-in presets
        let preset = builtinPresets.find(p => p.name === presetName);
        
        // If not found in built-in presets, check user presets
        if (!preset && userPresets) {
          preset = userPresets.find(p => p.name === presetName);
        }
        
        // If preset found, apply it
        if (preset) {
          console.log(`Applying preset: ${presetName}`);
          applySettings(preset.settings);
        } else {
          console.warn(`Preset not found: ${presetName}`);
        }
      }
      
      // Listen for back/forward browser navigation
      window.addEventListener('popstate', () => {
        checkUrlHash();
        
        // Check if the current hash isn't mixxs, and if so, hide the mixes gallery
        if (window.location.hash !== '#mixxs' && document.getElementById('mixes-gallery').classList.contains('active')) {
          document.getElementById('mixes-gallery').classList.remove('active');
        }
      });
      
      // Also listen for hash changes directly (for manual URL edits)
      window.addEventListener('hashchange', checkUrlHash);

      // Now handle the archive gallery functionality
      // Make sure closeButton exists before adding event listener
      if (closeButton) {
        closeButton.addEventListener('click', () => {
          archiveGallery.classList.remove('active');
        });
      } else {
        console.warn('Gallery close button not found!');
      }

      // Modify the existing menu click handler for archives
      if (archiveMenuItem) {
        archiveMenuItem.addEventListener('click', (e) => {
          // If archives section becomes active, show the gallery
          if (archiveMenuItem.classList.contains('active')) {
            loadArchiveContent();
            archiveGallery.classList.add('active');
          } else {
            archiveGallery.classList.remove('active');
          }
        });
      }

      // Function to load archive content from the server
      async function loadArchiveContent() {
        try {
          // Show loading state
          galleryContainer.innerHTML = '<div style="color: white; text-align: center; padding: 50px;">Loading archives...</div>';
          
          // Fetch albums from the server
          const response = await fetch('/api/archives');
          const data = await response.json();
          
          // Clear loading message
          galleryContainer.innerHTML = '';
          
          if (!data.albums || data.albums.length === 0) {
            galleryContainer.innerHTML = '<div style="color: white; text-align: center; padding: 50px;">No archives found. Add folders to the archive_assets directory.</div>';
            return;
          }
          
          // Create and append album elements
          data.albums.forEach(album => {
            const albumElement = createAlbumElement(album);
            galleryContainer.appendChild(albumElement);
          });
          
          // Enable image lazy loading
          setupLazyLoading();
          
          // Setup click events for the images
          setupImageClickEvents();
        } catch (error) {
          console.error('Error loading archives:', error);
          galleryContainer.innerHTML = '<div style="color: white; text-align: center; padding: 50px;">Error loading archives. Please try again later.</div>';
        }
      }

      // Function to create an album element
      function createAlbumElement(album) {
        const albumElement = document.createElement('div');
        albumElement.className = 'album';
        
        const titleElement = document.createElement('h2');
        titleElement.className = 'album-title';
        titleElement.textContent = album.title;
        albumElement.appendChild(titleElement);
        
        const imagesContainer = document.createElement('div');
        imagesContainer.className = 'album-images';
        
        album.images.forEach(image => {
          const imageContainer = document.createElement('div');
          imageContainer.className = 'album-image';
          
          const img = document.createElement('img');
          img.setAttribute('data-src', image.src); // Use data-src for lazy loading
          img.alt = image.alt;
          // Add a placeholder until the image loads
          img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1 1"%3E%3C/svg%3E';
          
          imageContainer.appendChild(img);
          imagesContainer.appendChild(imageContainer);
        });
        
        albumElement.appendChild(imagesContainer);
        return albumElement;
      }

      // Function to setup lazy loading for images
      function setupLazyLoading() {
        // Use Intersection Observer API for modern browsers
        if ('IntersectionObserver' in window) {
          const lazyImageObserver = new IntersectionObserver(entries => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                const lazyImage = entry.target;
                const src = lazyImage.getAttribute('data-src');
                
                if (src) {
                  lazyImage.src = src;
                  lazyImage.removeAttribute('data-src');
                }
                
                lazyImageObserver.unobserve(lazyImage);
              }
            });
          });
          
          // Observe all lazy images
          const lazyImages = document.querySelectorAll('img[data-src]');
          lazyImages.forEach(img => lazyImageObserver.observe(img));
        } else {
          // Fallback for browsers that don't support Intersection Observer
          // Just load all images immediately
          const lazyImages = document.querySelectorAll('img[data-src]');
          lazyImages.forEach(img => {
            img.src = img.getAttribute('data-src');
            img.removeAttribute('data-src');
          });
        }
      }

      // Function to set up click events for opening the fullscreen viewer
      function setupImageClickEvents() {
        document.querySelectorAll('.album-image').forEach((imageContainer) => {
          imageContainer.addEventListener('click', (e) => {
            // Find which album this image belongs to
            const albumElement = e.currentTarget.closest('.album');
            const allImages = albumElement.querySelectorAll('.album-image img');
            
            // Collect image data
            currentGalleryImages = Array.from(allImages).map(img => ({
              src: img.getAttribute('data-src') || img.src,
              alt: img.alt
            }));
            
            // Set current index
            currentImageIndex = Array.from(albumElement.querySelectorAll('.album-image')).indexOf(e.currentTarget);
            
            // Update and show viewer
            updateViewerImage();
            fullscreenViewer.classList.add('active');
          });
        });
      }

      // Fullscreen Viewer Functions
      // Close viewer
      if (closeViewerButton) {
        closeViewerButton.addEventListener('click', () => {
          fullscreenViewer.classList.remove('active');
        });
      }

      // Previous image
      if (prevButton) {
        prevButton.addEventListener('click', () => {
          if (currentGalleryImages.length === 0) return;
          
          currentImageIndex = (currentImageIndex - 1 + currentGalleryImages.length) % currentGalleryImages.length;
          updateViewerImage();
        });
      }

      // Next image
      if (nextButton) {
        nextButton.addEventListener('click', () => {
          if (currentGalleryImages.length === 0) return;
          
          currentImageIndex = (currentImageIndex + 1) % currentGalleryImages.length;
          updateViewerImage();
        });
      }

      // Keyboard navigation
      document.addEventListener('keydown', (e) => {
        if (!fullscreenViewer.classList.contains('active')) return;
        
        if (e.key === 'Escape') {
          fullscreenViewer.classList.remove('active');
        } else if (e.key === 'ArrowLeft') {
          if (prevButton) prevButton.click();
        } else if (e.key === 'ArrowRight') {
          if (nextButton) nextButton.click();
        }
      });

      // Update the displayed image in the fullscreen viewer
      function updateViewerImage() {
        if (!viewerImage || currentGalleryImages.length === 0 || currentImageIndex < 0 || currentImageIndex >= currentGalleryImages.length) {
          return;
        }
        
        const imageData = currentGalleryImages[currentImageIndex];
        viewerImage.src = imageData.src;
        viewerImage.alt = imageData.alt || '';
        
        // Optional: Show image caption
        let caption = fullscreenViewer.querySelector('.image-caption');
        if (imageData.alt) {
          if (!caption) {
            caption = document.createElement('div');
            caption.className = 'image-caption';
            fullscreenViewer.appendChild(caption);
          }
          caption.textContent = imageData.alt;
          caption.style.display = 'block';
        } else if (caption) {
          caption.style.display = 'none';
        }
      }

      // Check if archives is already active on page load
      if (archiveMenuItem && archiveMenuItem.classList.contains('active')) {
        loadArchiveContent();
        archiveGallery.classList.add('active');
      }
    });
  </script>
</body>
</html>